/*!
 * TSBuffer Proto Generator v1.7.1
 * -----------------------------------------
 * MIT LICENSE
 * KingWorks (C) Copyright 2022
 * https://github.com/k8w/tsbuffer
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('k8w-extend-native');
var fs = require('fs');
var path = require('path');
var tsbufferSchema = require('tsbuffer-schema');
var ts = require('typescript');
var k8wCrypto = require('k8w-crypto');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var ts__default = /*#__PURE__*/_interopDefaultLegacy(ts);

const SCALAR_TYPES = [
    'int',
    'uint',
    'double',
    'bigint',
    'bigint64',
    'biguint64',
].sort();
const BUFFER_TYPES = [
    'ArrayBuffer',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'BigInt64Array',
    'Uint8Array',
    'Uint16Array',
    'Uint32Array',
    'BigUint64Array',
    'Float32Array',
    'Float64Array',
].sort();
/**
 * 提取出有用的AST
 */
class AstParser {
    constructor(options) {
        var _a;
        this.keepComment = false;
        this.keepComment = (_a = options === null || options === void 0 ? void 0 : options.keepComment) !== null && _a !== void 0 ? _a : false;
    }
    /**
     * 解析整个文件
     * @param content
     */
    parseScript(content, logger) {
        let output = {};
        // 1. get flatten nodes
        let src = ts__default["default"].createSourceFile('', content, ts__default["default"].ScriptTarget.ES3, true, ts__default["default"].ScriptKind.TS);
        let nodes = this.getFlattenNodes(src, true);
        // 2. parse imports
        let imports = this.getScriptImports(src);
        // 3. node2schema
        for (let name in nodes) {
            output[name] = {
                isExport: nodes[name].isExport,
                schema: this.node2schema(nodes[name].node, imports, logger, undefined, nodes[name].comment)
            };
        }
        return output;
    }
    /** 解析顶层imports */
    getScriptImports(src) {
        let output = {};
        src.forEachChild(v => {
            if (v.kind !== ts__default["default"].SyntaxKind.ImportDeclaration) {
                return;
            }
            let node = v;
            // 仅支持从字符串路径import
            if (node.moduleSpecifier.kind !== ts__default["default"].SyntaxKind.StringLiteral) {
                return;
            }
            let importPath = node.moduleSpecifier.text;
            // import from 'xxx'
            if (!node.importClause) {
                return;
            }
            // default: import A from 'xxx'
            if (node.importClause.name) {
                output[node.importClause.name.text] = {
                    path: importPath,
                    targetName: 'default'
                };
            }
            // elements
            if (node.importClause.namedBindings && node.importClause.namedBindings.kind === ts__default["default"].SyntaxKind.NamedImports && node.importClause.namedBindings.elements) {
                node.importClause.namedBindings.elements.forEach(elem => {
                    // import { A as B } from 'xxx'
                    if (elem.propertyName) {
                        output[elem.name.text] = {
                            path: importPath,
                            targetName: elem.propertyName.text
                        };
                    }
                    // import { A } from 'xxx'
                    else {
                        output[elem.name.text] = {
                            path: importPath,
                            targetName: elem.name.text
                        };
                    }
                });
                // 暂不支持：import * as A from 'xxx'
            }
        });
        return output;
    }
    /**
     * 将Node展平（包括Namespace里的）
     * @param node
     * @param isExport 当node是Namespace时，其外层是否处于export
     */
    getFlattenNodes(node, isExport = false) {
        let output = {};
        // 检测到ExportDeclaration的项目，会在最后统一设为isExport
        let exportNames = {};
        // 检测到的顶级Modules（namespace）
        let namespaceExports = {};
        node.forEachChild(v => {
            var _a, _b;
            // 类型定义
            if (ts__default["default"].isInterfaceDeclaration(v) || ts__default["default"].isTypeAliasDeclaration(v) || ts__default["default"].isEnumDeclaration(v)) {
                // 外层允许export，且自身有被export
                let _isExport = Boolean(isExport && v.modifiers && v.modifiers.findIndex(v1 => v1.kind === ts__default["default"].SyntaxKind.ExportKeyword) > -1);
                // 是否为export default
                let _isExportDefault = _isExport && v.modifiers.findIndex(v1 => v1.kind === ts__default["default"].SyntaxKind.DefaultKeyword) > -1;
                output[v.name.text] = {
                    node: v.kind === ts__default["default"].SyntaxKind.TypeAliasDeclaration ? v.type : v,
                    comment: (_b = (_a = v.jsDoc) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.comment,
                    // export default的情况，本体作为不isExport，取而代之生成一个名为default的TypeReference来export
                    isExport: _isExport && !_isExportDefault
                };
                // 生成TypeReference
                if (_isExportDefault) {
                    output['default'] = {
                        node: ts__default["default"].createTypeReferenceNode(v.name, undefined),
                        isExport: true
                    };
                }
            }
            // namespace
            else if (ts__default["default"].isModuleDeclaration(v) && (v.flags & ts__default["default"].NodeFlags.Namespace)) {
                if (v.body && v.body.kind === ts__default["default"].SyntaxKind.ModuleBlock) {
                    // 外层允许export，且自身有被export
                    let _isExport = Boolean(isExport && v.modifiers && v.modifiers.findIndex(v1 => v1.kind === ts__default["default"].SyntaxKind.ExportKeyword) > -1);
                    // 递归生成子树
                    let children = this.getFlattenNodes(v.body, true);
                    namespaceExports[v.name.text] = {};
                    for (let item of Object.entries(children)) {
                        // 临时存储内部export
                        namespaceExports[v.name.text][item[0]] = item[1].isExport;
                        // 实际export还要考虑外部(_isExport)
                        item[1].isExport = item[1].isExport && _isExport;
                    }
                    // 展平子树
                    Object.entries(children).forEach(v1 => {
                        // 转换name为 A.B.C 的形式
                        output[v.name.text + '.' + v1[0]] = v1[1];
                    });
                }
            }
            // export
            else if (ts__default["default"].isExportDeclaration(v)) {
                if (!v.exportClause) {
                    return;
                }
                if ('elements' in v.exportClause) {
                    v.exportClause && v.exportClause.elements.forEach(elem => {
                        // export { A as B }
                        if (elem.propertyName) {
                            output[elem.name.text] = {
                                node: ts__default["default"].createTypeReferenceNode(elem.propertyName.text, undefined),
                                isExport: true
                            };
                        }
                        // export { A }
                        else {
                            exportNames[elem.name.text] = true;
                        }
                    });
                }
            }
            // export default
            else if (ts__default["default"].isExportAssignment(v)) {
                // 暂不支持 export = XXX
                if (v.isExportEquals) {
                    return;
                }
                output['default'] = {
                    node: ts__default["default"].createTypeReferenceNode(v.expression.getText(), undefined),
                    isExport: true
                };
            }
        });
        // exportNames
        // 后续export declaration的
        Object.keys(exportNames).forEach(v => {
            if (output[v]) {
                output[v].isExport = true;
            }
        });
        // export default namespace 的情况
        if (output['default'] && ts__default["default"].isTypeReferenceNode(output['default'].node)) {
            let typeName = this._typeNameToString(output['default'].node.typeName);
            // 确实是export default namespace
            if (namespaceExports[typeName]) {
                delete output['default'];
                // 遍历所有 typeName.XXX
                for (let key in namespaceExports[typeName]) {
                    // 内部也export的
                    if (namespaceExports[typeName][key]) {
                        // 增加 default.XXX 到 typeName.XXX 的引用
                        output['default.' + key] = {
                            node: ts__default["default"].createTypeReferenceNode(typeName + '.' + key, undefined),
                            isExport: true
                        };
                    }
                }
            }
        }
        return output;
    }
    node2schema(node, imports, logger, fullText, comment) {
        let schema = this._node2schema(node, imports, logger);
        if (this.keepComment) {
            if (comment) {
                schema.comment = comment;
            }
            else {
                if (fullText === undefined) {
                    fullText = node.getFullText();
                }
                fullText = fullText.trim();
                if (fullText.startsWith('/**')) {
                    let endPos = fullText.indexOf('*/');
                    if (endPos > -1) {
                        let comment = fullText.substr(3, endPos - 3).trim().split('\n')
                            .map(v => v.trim().replace(/^\* ?/, '')).filter(v => !!v).join('\n');
                        schema.comment = comment;
                    }
                }
            }
        }
        return schema;
    }
    _node2schema(node, imports, logger) {
        var _a, _b;
        // 去除外层括弧
        while (ts__default["default"].isParenthesizedTypeNode(node)) {
            node = node.type;
        }
        // AnyType
        if (node.kind === ts__default["default"].SyntaxKind.AnyKeyword || node.kind === ts__default["default"].SyntaxKind.UnknownKeyword) {
            return {
                type: tsbufferSchema.SchemaType.Any
            };
        }
        // BufferType
        if (ts__default["default"].isTypeReferenceNode(node)) {
            let ref = this._getReferenceTypeSchema(node.typeName, imports);
            if (BUFFER_TYPES.binarySearch(ref.target) > -1) {
                let output = {
                    type: tsbufferSchema.SchemaType.Buffer
                };
                let target = ref.target;
                if (target !== 'ArrayBuffer') {
                    output.arrayType = target;
                }
                return output;
            }
        }
        // BooleanType
        if (node.kind === ts__default["default"].SyntaxKind.BooleanKeyword) {
            return {
                type: tsbufferSchema.SchemaType.Boolean
            };
        }
        // ObjectType
        if (node.kind === ts__default["default"].SyntaxKind.ObjectKeyword) {
            return {
                type: tsbufferSchema.SchemaType.Object
            };
        }
        // NumberType
        if (node.kind === ts__default["default"].SyntaxKind.NumberKeyword) {
            return {
                type: tsbufferSchema.SchemaType.Number
            };
        }
        else if (node.kind === ts__default["default"].SyntaxKind.BigIntKeyword) {
            return {
                type: tsbufferSchema.SchemaType.Number,
                scalarType: 'bigint'
            };
        }
        // Scalar value types
        if (ts__default["default"].isTypeReferenceNode(node) && ts__default["default"].isIdentifier(node.typeName) && SCALAR_TYPES.binarySearch(node.typeName.text) > -1) {
            return {
                type: tsbufferSchema.SchemaType.Number,
                scalarType: node.typeName.text
            };
        }
        // StringType
        if (node.kind === ts__default["default"].SyntaxKind.StringKeyword) {
            return { type: tsbufferSchema.SchemaType.String };
        }
        // ArrayType: xxx[]
        if (ts__default["default"].isArrayTypeNode(node)) {
            return {
                type: tsbufferSchema.SchemaType.Array,
                elementType: this.node2schema(node.elementType, imports, logger, node.getFullText())
            };
        }
        // ArrayType: Array<T>
        if (this._isLocalReference(node, imports, 'Array') && node.typeArguments) {
            return {
                type: tsbufferSchema.SchemaType.Array,
                elementType: this.node2schema(node.typeArguments[0], imports, logger, node.getFullText())
            };
        }
        // TupleType
        if (ts__default["default"].isTupleTypeNode(node)) {
            let optionalStartIndex;
            let output = {
                type: tsbufferSchema.SchemaType.Tuple,
                elementTypes: node.elements.map((v, i) => {
                    if (v.kind === ts__default["default"].SyntaxKind.OptionalType) {
                        if (optionalStartIndex === undefined) {
                            optionalStartIndex = i;
                        }
                        return this.node2schema(v.type, imports, logger, v.getFullText());
                    }
                    else {
                        return this.node2schema(v, imports, logger, v.getFullText());
                    }
                })
            };
            if (optionalStartIndex !== undefined) {
                output.optionalStartIndex = optionalStartIndex;
            }
            return output;
        }
        // LiteralType
        // LiteralType: string | number | boolean
        if (ts__default["default"].isLiteralTypeNode(node)) {
            if (ts__default["default"].isStringLiteral(node.literal)) {
                return {
                    type: tsbufferSchema.SchemaType.Literal,
                    literal: node.literal.text
                };
            }
            else if (ts__default["default"].isNumericLiteral(node.literal)) {
                return {
                    type: tsbufferSchema.SchemaType.Literal,
                    literal: parseFloat(node.literal.text)
                };
            }
            else if (node.literal.kind === ts__default["default"].SyntaxKind.TrueKeyword) {
                return {
                    type: tsbufferSchema.SchemaType.Literal,
                    literal: true
                };
            }
            else if (node.literal.kind === ts__default["default"].SyntaxKind.FalseKeyword) {
                return {
                    type: tsbufferSchema.SchemaType.Literal,
                    literal: false
                };
            }
            else if (node.literal.kind === ts__default["default"].SyntaxKind.NullKeyword) {
                return {
                    type: tsbufferSchema.SchemaType.Literal,
                    literal: null
                };
            }
        }
        // Literal: undefined
        else if (node.kind === ts__default["default"].SyntaxKind.UndefinedKeyword) {
            return {
                type: tsbufferSchema.SchemaType.Literal,
                literal: undefined
            };
        }
        // EnumType
        if (ts__default["default"].isEnumDeclaration(node)) {
            let initializer = 0;
            let schema = {
                type: tsbufferSchema.SchemaType.Enum,
                members: node.members.map((v, i) => {
                    if (v.initializer) {
                        if (ts__default["default"].isStringLiteral(v.initializer)) {
                            initializer = NaN;
                            return {
                                id: i,
                                name: v.name.getText(),
                                value: v.initializer.text
                            };
                        }
                        else if (ts__default["default"].isNumericLiteral(v.initializer)) {
                            initializer = parseFloat(v.initializer.text);
                            return {
                                id: i,
                                name: v.name.getText(),
                                value: initializer++
                            };
                        }
                        // 负数
                        else if (ts__default["default"].isPrefixUnaryExpression(v.initializer) && v.initializer.operator === ts__default["default"].SyntaxKind.MinusToken) {
                            initializer = parseFloat(v.initializer.operand.getText()) * -1;
                            return {
                                id: i,
                                name: v.name.getText(),
                                value: initializer++
                            };
                        }
                        else {
                            logger === null || logger === void 0 ? void 0 : logger.log('initializer', v.initializer);
                            throw new Error('Enum initializer type error: ' + ts__default["default"].SyntaxKind[v.initializer.kind]);
                        }
                    }
                    else {
                        return {
                            id: i,
                            name: v.name.getText(),
                            value: initializer++
                        };
                    }
                })
            };
            (_a = this.pre) === null || _a === void 0 ? void 0 : _a.preEnumSchemas.push(schema);
            return schema;
        }
        // InterfaceType
        if (ts__default["default"].isInterfaceDeclaration(node) || ts__default["default"].isTypeLiteralNode(node)) {
            // extends
            let extendsInterface;
            if (ts__default["default"].isInterfaceDeclaration(node) && node.heritageClauses) {
                extendsInterface = [];
                node.heritageClauses.forEach(v => {
                    v.types.forEach(type => {
                        let extendsType = this._node2schema(type, imports, logger);
                        extendsInterface.push(extendsType);
                    });
                });
            }
            let properties = [];
            let indexSignature;
            node.members.forEach((member, i) => {
                // properties
                if (ts__default["default"].isPropertySignature(member)) {
                    if (ts__default["default"].isComputedPropertyName(member.name)) {
                        throw new Error('ComputedPropertyName is not supported at now');
                    }
                    if (!member.type) {
                        throw new Error(`Field must have a type: ${member.name.text}`);
                    }
                    let property = {
                        id: i,
                        name: member.name.text,
                        type: this.node2schema(member.type, imports, logger, member.getFullText())
                    };
                    // optional
                    if (member.questionToken) {
                        property.optional = true;
                    }
                    properties.push(property);
                }
                // indexSignature
                else if (ts__default["default"].isIndexSignatureDeclaration(member)) {
                    if (!member.type || !member.parameters[0].type) {
                        throw new Error('Error index signature: ' + member.getText());
                    }
                    let keyType;
                    if (member.parameters[0].type.kind === ts__default["default"].SyntaxKind.NumberKeyword) {
                        keyType = 'Number';
                    }
                    else {
                        keyType = 'String';
                    }
                    indexSignature = {
                        keyType: keyType,
                        type: this.node2schema(member.type, imports, logger, member.getFullText())
                    };
                }
            });
            // output
            let output = {
                type: tsbufferSchema.SchemaType.Interface
            };
            if (extendsInterface) {
                output.extends = extendsInterface.map((v, i) => ({
                    id: i,
                    type: v
                }));
            }
            if (properties.length) {
                output.properties = properties;
            }
            if (indexSignature) {
                output.indexSignature = indexSignature;
            }
            return output;
        }
        // IndexedAccessType
        if (ts__default["default"].isIndexedAccessTypeNode(node)) {
            // A['a']
            if (ts__default["default"].isLiteralTypeNode(node.indexType)) {
                let index;
                if (ts__default["default"].isStringLiteral(node.indexType.literal) || ts__default["default"].isNumericLiteral(node.indexType.literal)) {
                    index = node.indexType.literal.text;
                }
                else if (node.indexType.literal.kind === ts__default["default"].SyntaxKind.TrueKeyword
                    || node.indexType.literal.kind === ts__default["default"].SyntaxKind.FalseKeyword
                    || node.indexType.literal.kind === ts__default["default"].SyntaxKind.NullKeyword
                    || node.indexType.literal.kind === ts__default["default"].SyntaxKind.UndefinedKeyword) {
                    index = node.indexType.literal.getText();
                }
                else {
                    throw new Error(`Error indexType literal: ${node.getText()}`);
                }
                let objectType = this.node2schema(node.objectType, imports, logger, node.getFullText());
                if (!this._isInterfaceReference(objectType)) {
                    throw new Error(`ObjectType for IndexedAccess must be interface or interface reference`);
                }
                return {
                    type: tsbufferSchema.SchemaType.IndexedAccess,
                    index: index,
                    objectType: objectType
                };
            }
            // A['a' | 'b']
            else if (ts__default["default"].isUnionTypeNode(node.indexType)) ;
            else {
                throw new Error(`Error IndexedAccessType indexType: ${node.getText()}`);
            }
        }
        // UnionType
        if (ts__default["default"].isUnionTypeNode(node)) {
            return {
                type: tsbufferSchema.SchemaType.Union,
                members: node.types.map((v, i) => ({
                    id: i,
                    type: this.node2schema(v, imports, logger, v.getFullText())
                }))
            };
        }
        // IntersectionType
        if (ts__default["default"].isIntersectionTypeNode(node)) {
            return {
                type: tsbufferSchema.SchemaType.Intersection,
                members: node.types.map((v, i) => ({
                    id: i,
                    type: this.node2schema(v, imports, logger, v.getFullText())
                }))
            };
        }
        // PickType & OmitType
        if (this._isLocalReference(node, imports, ['Pick', 'Omit'])) {
            let nodeName;
            if (ts__default["default"].isTypeReferenceNode(node)) {
                nodeName = node.typeName.getText();
            }
            else if (ts__default["default"].isExpressionWithTypeArguments(node)) {
                nodeName = node.expression.getText();
            }
            else {
                // @ts-expect-error
                throw new Error(`Invalid ts.Node kind for Pick/Omit: ${node.kind}`);
            }
            if (!node.typeArguments || node.typeArguments.length != 2) {
                throw new Error(`Illeagle ${nodeName}Type: ` + node.getText());
            }
            let target = this.node2schema(node.typeArguments[0], imports, logger, node.getFullText());
            if (!this._isInterfaceReference(target) && target.type !== tsbufferSchema.SchemaType.Union && target.type !== tsbufferSchema.SchemaType.Intersection) {
                throw new Error(`Illeagle ${nodeName}Type: ` + node.getText());
            }
            let preKey = this._getPreKey(this.node2schema(node.typeArguments[1], imports, logger, node.getFullText()), logger);
            let output = Object.assign({
                target: target,
                keys: [],
                pre: { key: preKey }
            }, nodeName === 'Pick' ? { type: tsbufferSchema.SchemaType.Pick } : { type: tsbufferSchema.SchemaType.Omit });
            (_b = this.pre) === null || _b === void 0 ? void 0 : _b.prePickOmitSchemas.push(output);
            return output;
        }
        // PartialType
        if (this._isLocalReference(node, imports, 'Partial')) {
            if (!node.typeArguments || node.typeArguments.length != 1) {
                throw new Error('Illeagle PartialType: ' + node.getText());
            }
            let target = this.node2schema(node.typeArguments[0], imports, logger, node.getFullText());
            if (!this._isInterfaceReference(target)) {
                throw new Error('Illeagle PartialType: ' + node.getText());
            }
            return {
                type: tsbufferSchema.SchemaType.Partial,
                target: target
            };
        }
        // OverwriteType
        if (ts__default["default"].isTypeReferenceNode(node) && this._typeNameToString(node.typeName) === 'Overwrite') {
            if (!node.typeArguments || node.typeArguments.length != 2) {
                throw new Error(`Illeagle OverwriteType: ` + node.getText());
            }
            let target = this.node2schema(node.typeArguments[0], imports, logger, node.getFullText());
            if (!this._isInterfaceReference(target)) {
                throw new Error(`Illeagle OverwriteType: ` + node.getText());
            }
            let overwrite = this.node2schema(node.typeArguments[1], imports, logger, node.getFullText());
            if (!this._isInterfaceReference(overwrite)) {
                throw new Error(`Illeagle OverwriteType: ` + node.getText());
            }
            return {
                type: tsbufferSchema.SchemaType.Overwrite,
                target: target,
                overwrite: overwrite
            };
        }
        // DateType
        if (ts__default["default"].isTypeReferenceNode(node) && this._typeNameToString(node.typeName) === 'Date' && !imports['Date']) {
            return {
                type: tsbufferSchema.SchemaType.Date
            };
        }
        // NonNullableType
        if (ts__default["default"].isTypeReferenceNode(node) && this._typeNameToString(node.typeName) === 'NonNullable' && !imports['NonNullable']) {
            let target = this.node2schema(node.typeArguments[0], imports, logger, node.getFullText());
            return {
                type: tsbufferSchema.SchemaType.NonNullable,
                target: target
            };
        }
        // Keyof
        if (ts__default["default"].isTypeOperatorNode(node) && node.operator === ts__default["default"].SyntaxKind.KeyOfKeyword) {
            return {
                type: tsbufferSchema.SchemaType.Keyof,
                target: this.node2schema(node.type, imports, logger),
            };
        }
        // ReferenceType放最后（因为很多其它类型，如Pick等，都解析为ReferenceNode）
        if (ts__default["default"].isTypeReferenceNode(node)) {
            return this._getReferenceTypeSchema(node.typeName, imports);
        }
        if (ts__default["default"].isExpressionWithTypeArguments(node)) {
            return this._getReferenceTypeSchema(node.expression.getText(), imports);
        }
        logger === null || logger === void 0 ? void 0 : logger.debug(node);
        throw new Error('Cannot resolve type: ' + node.getText());
    }
    /**
     * A -> A
     * A.B -> A.B
     * @param name
     */
    _typeNameToString(name) {
        if (ts__default["default"].isIdentifier(name)) {
            return name.text;
        }
        else {
            let left = ts__default["default"].isIdentifier(name.left) ? name.left.text : this._typeNameToString(name.left);
            return left + '.' + name.right.text;
        }
    }
    _getReferenceTypeSchema(name, imports) {
        if (typeof name !== 'string') {
            name = this._typeNameToString(name);
        }
        let arrName = name.split('.');
        let importItem = imports[arrName[0]];
        if (importItem) {
            let importName = arrName.slice();
            importName[0] = importItem.targetName;
            return {
                type: tsbufferSchema.SchemaType.Reference,
                target: importItem.path + '/' + importName.join('.')
            };
        }
        else {
            let ref = {
                type: tsbufferSchema.SchemaType.Reference,
                target: name
            };
            return ref;
        }
    }
    _isLocalReference(node, imports, referenceName) {
        let ref;
        if (ts__default["default"].isTypeReferenceNode(node)) {
            ref = this._getReferenceTypeSchema(node.typeName, imports);
        }
        else if (ts__default["default"].isExpressionWithTypeArguments(node)) {
            ref = this._getReferenceTypeSchema(node.expression.getText(), imports);
        }
        else {
            return false;
        }
        if (typeof referenceName === 'string') {
            referenceName = [referenceName];
        }
        for (let name of referenceName) {
            if (ref.target.indexOf('/') === -1 && ref.target === name) {
                return name;
            }
        }
        return false;
    }
    _getPreKey(schema, logger) {
        if (schema.type === 'Union' || schema.type === 'Intersection' || schema.type === 'Literal' || this._isTypeReference(schema)) {
            return schema;
        }
        else {
            logger === null || logger === void 0 ? void 0 : logger.log('Illeagle Pick keys:', schema);
            throw new Error('Illeagle Pick keys: ' + JSON.stringify(schema, null, 2));
        }
    }
    _isInterfaceReference(schema) {
        return this._isTypeReference(schema) ||
            schema.type === 'Interface' ||
            schema.type === 'Pick' ||
            schema.type === 'Partial' ||
            schema.type === 'Omit' ||
            schema.type === 'Overwrite';
    }
    _isTypeReference(schema) {
        return schema.type === 'Reference' || schema.type === 'IndexedAccess' || schema.type === 'Keyof';
    }
}

class EncodeIdUtil {
    /**
    * 将字符串映射为从0开始的自增数字，支持向后兼容
    * @param values object将视为 md5(JSON.stringify(obj))
    * @param compatible 需要向后兼容的结果集（新字段用新数字，旧字段ID不变）
    * @returns 返回的顺序必定与values传入的顺序相同
    */
    static genEncodeIds(values, compatible) {
        var _a, _b;
        // 新元素的起始ID，有compatible则从其下一个开始，全新模式从0开始
        let nextId = 0;
        let existKeyId = compatible ? compatible.reduce((prev, next) => {
            prev[next.key] = next.id;
            nextId = Math.max(nextId, next.id + 1);
            return prev;
        }, {}) : {};
        let output = [];
        let keys = values.map(v => this.getKey(v));
        for (let key of keys) {
            let id = (_a = existKeyId[key]) !== null && _a !== void 0 ? _a : nextId++;
            existKeyId[key] = id;
            output.push({ key: key, id: id });
        }
        // 可优化节点>=32,4096
        let uniqueKeyLength = keys.distinct().length;
        if (nextId > 32 && uniqueKeyLength <= 32 || nextId > 4096 && uniqueKeyLength <= 4096) {
            (_b = this.onGenCanOptimized) === null || _b === void 0 ? void 0 : _b.call(this);
        }
        return output;
    }
    static getSchemaEncodeKeys(schema) {
        switch (schema.type) {
            case 'Enum': {
                return schema.members.map(v => '' + v.value);
            }
            case 'Interface': {
                return schema.properties ? schema.properties.map(v => v.name) : [];
            }
            case 'Intersection':
            case 'Union':
                return schema.members.map(v => k8wCrypto.Crypto.md5(JSON.stringify(v.type)));
            default:
                return [];
        }
    }
    static getKey(value) {
        return typeof (value) === 'object' ? k8wCrypto.Crypto.md5(JSON.stringify(value)) : '' + value;
    }
    static getSchemaEncodeIds(schema) {
        if (!schema) {
            return undefined;
        }
        switch (schema.type) {
            case 'Enum': {
                return schema.members.map(v => ({ key: EncodeIdUtil.getKey(v.value), id: v.id }));
            }
            case 'Interface': {
                return schema.properties ? schema.properties.map(v => ({ key: EncodeIdUtil.getKey(v.name), id: v.id })) : undefined;
            }
            case 'Intersection':
            case 'Union':
                return schema.members.map(v => ({ key: k8wCrypto.Crypto.md5(JSON.stringify(v.type)), id: v.id }));
            default:
                return undefined;
        }
    }
}

class ProtoHelper {
    constructor(proto) {
        this.proto = proto;
    }
    parseReference(schema) {
        // Reference
        if (schema.type === tsbufferSchema.SchemaType.Reference) {
            let parsedSchema = this.proto[schema.target];
            if (!parsedSchema) {
                throw new Error(`Cannot find reference target: ${schema.target}`);
            }
            if (this.isTypeReference(parsedSchema)) {
                return this.parseReference(parsedSchema);
            }
            else {
                return parsedSchema;
            }
        }
        // IndexedAccess
        else if (schema.type === tsbufferSchema.SchemaType.IndexedAccess) {
            if (!this.isInterface(schema.objectType)) {
                throw new Error(`Error objectType: ${schema.objectType.type}`);
            }
            // find prop item
            let flat = this.getFlatInterfaceSchema(schema.objectType);
            let propItem = flat.properties.find(v => v.name === schema.index);
            let propType;
            if (propItem) {
                propType = propItem.type;
            }
            else {
                if (flat.indexSignature) {
                    propType = flat.indexSignature.type;
                }
                else {
                    throw new Error(`Error index: ${schema.index}`);
                }
            }
            // optional -> | undefined
            if (propItem && propItem.optional && // 引用的字段是optional
                (propItem.type.type !== tsbufferSchema.SchemaType.Union // 自身不为Union
                    // 或自身为Union，但没有undefined成员条件
                    || propItem.type.members.findIndex(v => v.type.type === tsbufferSchema.SchemaType.Literal && v.type.literal === undefined) === -1)) {
                propType = {
                    type: tsbufferSchema.SchemaType.Union,
                    members: [
                        { id: 0, type: propType },
                        {
                            id: 1,
                            type: {
                                type: tsbufferSchema.SchemaType.Literal,
                                literal: undefined
                            }
                        }
                    ]
                };
            }
            return this.isTypeReference(propType) ? this.parseReference(propType) : propType;
        }
        else if (schema.type === tsbufferSchema.SchemaType.Keyof) {
            if (!this.isInterface(schema.target)) {
                throw new Error(('Invalid keyof target type: ' + schema.target.type));
            }
            let flatInterface = this.getFlatInterfaceSchema(schema.target);
            return {
                type: tsbufferSchema.SchemaType.Union,
                members: flatInterface.properties.map((v, i) => ({
                    id: i,
                    type: {
                        type: tsbufferSchema.SchemaType.Literal,
                        literal: v.name
                    }
                }))
            };
        }
        else {
            return schema;
        }
    }
    isInterface(schema, excludeReference = false) {
        if (!excludeReference && this.isTypeReference(schema)) {
            let parsed = this.parseReference(schema);
            return this.isInterface(parsed, excludeReference);
        }
        else {
            return schema.type === tsbufferSchema.SchemaType.Interface ||
                schema.type === tsbufferSchema.SchemaType.Pick ||
                schema.type === tsbufferSchema.SchemaType.Partial ||
                schema.type === tsbufferSchema.SchemaType.Omit ||
                schema.type === tsbufferSchema.SchemaType.Overwrite;
        }
    }
    isTypeReference(schema) {
        return schema.type === tsbufferSchema.SchemaType.Reference || schema.type === tsbufferSchema.SchemaType.IndexedAccess;
    }
    getUnionProperties(schema) {
        return this._addUnionProperties([], schema.members.map(v => v.type));
    }
    /**
     * unionProperties: 在Union或Intersection类型中，出现在任意member中的字段
     */
    _addUnionProperties(unionProperties, schemas) {
        for (let i = 0, len = schemas.length; i < len; ++i) {
            let schema = this.parseReference(schemas[i]);
            // Interface及其Ref 加入interfaces
            if (this.isInterface(schema)) {
                let flat = this.getFlatInterfaceSchema(schema);
                flat.properties.forEach(v => {
                    unionProperties.binaryInsert(v.name, true);
                });
                if (flat.indexSignature) {
                    let key = `[[${flat.indexSignature.keyType}]]`;
                    unionProperties.binaryInsert(key, true);
                }
            }
            // Intersection/Union 递归合并unionProperties
            else if (schema.type === tsbufferSchema.SchemaType.Intersection || schema.type === tsbufferSchema.SchemaType.Union) {
                this._addUnionProperties(unionProperties, schema.members.map(v => v.type));
            }
        }
        return unionProperties;
    }
    /**
     * 将unionProperties 扩展到 InterfaceTypeSchema中（optional的any类型）
     * 以此来跳过对它们的检查（用于Intersection/Union）
     */
    applyUnionProperties(schema, unionProperties) {
        let newSchema = {
            ...schema,
            properties: schema.properties.slice()
        };
        for (let prop of unionProperties) {
            if (prop === '[[String]]') {
                newSchema.indexSignature = newSchema.indexSignature || {
                    keyType: tsbufferSchema.SchemaType.String,
                    type: { type: tsbufferSchema.SchemaType.Any }
                };
            }
            else if (prop === '[[Number]]') {
                newSchema.indexSignature = newSchema.indexSignature || {
                    keyType: tsbufferSchema.SchemaType.Number,
                    type: { type: tsbufferSchema.SchemaType.Any }
                };
            }
            else if (!schema.properties.find(v => v.name === prop)) {
                newSchema.properties.push({
                    id: -1,
                    name: prop,
                    optional: true,
                    type: {
                        type: tsbufferSchema.SchemaType.Any
                    }
                });
            }
        }
        return newSchema;
    }
    /**
     * 将interface及其引用转换为展平的schema
     */
    getFlatInterfaceSchema(schema) {
        if (this.isTypeReference(schema)) {
            let parsed = this.parseReference(schema);
            if (parsed.type !== tsbufferSchema.SchemaType.Interface) {
                throw new Error(`Cannot flatten non interface type: ${parsed.type}`);
            }
            return this.getFlatInterfaceSchema(parsed);
        }
        else if (schema.type === tsbufferSchema.SchemaType.Interface) {
            return this._flattenInterface(schema);
        }
        else {
            return this._flattenMappedType(schema);
        }
    }
    /**
     * 展平interface
     */
    _flattenInterface(schema) {
        let properties = {};
        let indexSignature;
        // 自身定义的properties和indexSignature优先级最高
        if (schema.properties) {
            for (let prop of schema.properties) {
                properties[prop.name] = {
                    optional: prop.optional,
                    type: prop.type
                };
            }
        }
        if (schema.indexSignature) {
            indexSignature = schema.indexSignature;
        }
        // extends的优先级次之，补全没有定义的字段
        if (schema.extends) {
            for (let extend of schema.extends) {
                // 解引用
                let parsedExtRef = this.parseReference(extend.type);
                if (parsedExtRef.type !== tsbufferSchema.SchemaType.Interface) {
                    throw new Error('SchemaError: extends must from interface but from ' + parsedExtRef.type);
                }
                // 递归展平extends
                let flatenExtendsSchema = this.getFlatInterfaceSchema(parsedExtRef);
                // properties
                if (flatenExtendsSchema.properties) {
                    for (let prop of flatenExtendsSchema.properties) {
                        if (!properties[prop.name]) {
                            properties[prop.name] = {
                                optional: prop.optional,
                                type: prop.type
                            };
                        }
                    }
                }
                // indexSignature
                if (flatenExtendsSchema.indexSignature && !indexSignature) {
                    indexSignature = flatenExtendsSchema.indexSignature;
                }
            }
        }
        return {
            type: tsbufferSchema.SchemaType.Interface,
            properties: Object.entries(properties).map((v, i) => ({
                id: i,
                name: v[0],
                optional: v[1].optional,
                type: v[1].type
            })),
            indexSignature: indexSignature
        };
    }
    /** 将MappedTypeSchema转换为展平的Interface
     */
    _flattenMappedType(schema) {
        // target 解引用
        let target;
        if (this.isTypeReference(schema.target)) {
            let parsed = this.parseReference(schema.target);
            target = parsed;
        }
        else {
            target = schema.target;
        }
        let flatTarget;
        // 内层仍然为MappedType 递归之
        if (target.type === tsbufferSchema.SchemaType.Pick || target.type === tsbufferSchema.SchemaType.Partial || target.type === tsbufferSchema.SchemaType.Omit || target.type === tsbufferSchema.SchemaType.Overwrite) {
            flatTarget = this._flattenMappedType(target);
        }
        else if (target.type === tsbufferSchema.SchemaType.Interface) {
            flatTarget = this._flattenInterface(target);
        }
        else {
            throw new Error(`Invalid target.type: ${target.type}`);
        }
        // 开始执行Mapped逻辑
        if (schema.type === tsbufferSchema.SchemaType.Pick) {
            let properties = [];
            for (let key of schema.keys) {
                let propItem = flatTarget.properties.find(v => v.name === key);
                if (propItem) {
                    properties.push({
                        id: properties.length,
                        name: key,
                        optional: propItem.optional,
                        type: propItem.type
                    });
                }
                else if (flatTarget.indexSignature) {
                    properties.push({
                        id: properties.length,
                        name: key,
                        type: flatTarget.indexSignature.type
                    });
                }
                else {
                    throw new Error(`Cannot find pick key [${key}]`);
                }
            }
            return {
                type: tsbufferSchema.SchemaType.Interface,
                properties: properties
            };
        }
        else if (schema.type === tsbufferSchema.SchemaType.Partial) {
            for (let v of flatTarget.properties) {
                v.optional = true;
            }
            return flatTarget;
        }
        else if (schema.type === tsbufferSchema.SchemaType.Omit) {
            for (let key of schema.keys) {
                flatTarget.properties.removeOne(v => v.name === key);
            }
            return flatTarget;
        }
        else if (schema.type === tsbufferSchema.SchemaType.Overwrite) {
            let overwrite = this.getFlatInterfaceSchema(schema.overwrite);
            if (overwrite.indexSignature) {
                flatTarget.indexSignature = overwrite.indexSignature;
            }
            for (let prop of overwrite.properties) {
                flatTarget.properties.removeOne(v => v.name === prop.name);
                flatTarget.properties.push(prop);
            }
            return flatTarget;
        }
        else {
            throw new Error(`Unknown type: ${schema.type}`);
        }
    }
    parseMappedType(schema) {
        let parents = [];
        let child = schema;
        do {
            parents.push(child);
            child = this.parseReference(child.target);
        } while (child.type === tsbufferSchema.SchemaType.Pick || child.type === tsbufferSchema.SchemaType.Omit || child.type === tsbufferSchema.SchemaType.Partial || child.type === tsbufferSchema.SchemaType.Overwrite);
        // Final
        if (child.type === tsbufferSchema.SchemaType.Interface) {
            return child;
        }
        // PickOmit<A|B> === PickOmit<A> | PickOmit<B>
        else if (child.type === tsbufferSchema.SchemaType.Union) {
            let newSchema = {
                type: tsbufferSchema.SchemaType.Union,
                members: child.members.map(v => {
                    // 从里面往外装
                    let type = v.type;
                    for (let i = parents.length - 1; i > -1; --i) {
                        let parent = parents[i];
                        type = {
                            ...parent,
                            target: type
                        };
                    }
                    return {
                        id: v.id,
                        type: type
                    };
                })
            };
            return newSchema;
        }
        else {
            throw new Error(`Unsupported pattern ${schema.type}<${child.type}>`);
        }
    }
}

class SchemaUtil {
    /**
     * 解析一个Schema引用到的其它类型
     * @param schema
     */
    static getUsedReferences(schemas) {
        var _a;
        if (!Array.isArray(schemas)) {
            schemas = [schemas];
        }
        let output = [];
        for (let schema of schemas) {
            switch (schema.type) {
                case tsbufferSchema.SchemaType.Array:
                    output = output.concat(this.getUsedReferences(schema.elementType));
                    break;
                case tsbufferSchema.SchemaType.Tuple:
                    output = output.concat(this.getUsedReferences(schema.elementTypes));
                    break;
                case tsbufferSchema.SchemaType.Interface:
                    if (schema.extends) {
                        output = output.concat(this.getUsedReferences(schema.extends.map(v => v.type)));
                    }
                    if (schema.properties) {
                        output = output.concat(this.getUsedReferences(schema.properties.map(v => v.type)));
                    }
                    if (schema.indexSignature) {
                        output = output.concat(this.getUsedReferences(schema.indexSignature.type));
                    }
                    break;
                case tsbufferSchema.SchemaType.IndexedAccess:
                    output = output.concat(this.getUsedReferences(schema.objectType));
                    break;
                case tsbufferSchema.SchemaType.Reference:
                    output.push(schema);
                    break;
                case tsbufferSchema.SchemaType.Union:
                case tsbufferSchema.SchemaType.Intersection:
                    output = output.concat(this.getUsedReferences(schema.members.map(v => v.type)));
                    break;
                case tsbufferSchema.SchemaType.Pick:
                case tsbufferSchema.SchemaType.Omit:
                    output = output.concat(this.getUsedReferences(schema.target));
                    if ((_a = schema.pre) === null || _a === void 0 ? void 0 : _a.key) {
                        output = output.concat(this.getUsedReferences(schema.pre.key));
                    }
                    break;
                case tsbufferSchema.SchemaType.Partial:
                case tsbufferSchema.SchemaType.NonNullable:
                case tsbufferSchema.SchemaType.Keyof:
                    output = output.concat(this.getUsedReferences(schema.target));
                    break;
                case tsbufferSchema.SchemaType.Overwrite:
                    output = output.concat(this.getUsedReferences(schema.target));
                    output = output.concat(this.getUsedReferences(schema.overwrite));
                    break;
            }
        }
        return output;
    }
}

class ProtoGenerator {
    constructor(options = {}) {
        this.options = {
            baseDir: '.',
            verbose: false,
            readFile: (v => fs__default["default"].readFileSync(path__default["default"].resolve(this.options.baseDir, v)).toString()),
            /** 默认将 module 解析为 chdir 下的node_modules */
            resolveModule: defaultResolveModule
        };
        Object.assign(this.options, options);
        this._astParser = new AstParser(options);
    }
    /**
     * 生成FileSchema
     * 对modules（例如node_modules）的引用，也会全部转为相对路径引用
     * @param paths 于baseDir的相对路径
     * @param options
     */
    async generate(paths, options = {}) {
        var _a;
        let output = {};
        const logger = 'logger' in options ? options.logger : console;
        if (typeof paths === 'string') {
            paths = [paths];
        }
        // 确保路径安全，再次将paths转为相对路径
        paths = paths.map(v => path__default["default"].relative(this.options.baseDir, path__default["default"].resolve(this.options.baseDir, v)));
        if (this.options.verbose) {
            logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', 'generate', `Ready to generate ${paths.length} file`);
            logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', 'generate', 'BaseDir=' + this.options.baseDir);
        }
        // AST CACHE
        let astCache = (_a = this.options.astCache) !== null && _a !== void 0 ? _a : {};
        // Init Post
        this._astParser.pre = {
            prePickOmitSchemas: [],
            preEnumSchemas: []
        };
        // 默认filter是导出所有export项
        let filter = options.filter || (v => v.isExport);
        // 是要被导出的直接引用的项目
        let exports = {};
        // 生成这几个文件的AST CACHE
        for (let filepath of paths) {
            if (this.options.verbose) {
                logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', 'generate', 'FilePath=' + filepath);
            }
            // 生成该文件的AST
            let { ast, astKey } = await this._getAst(filepath, astCache, logger);
            if (this.options.verbose) {
                logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', 'generate', 'AstLoaded Key=' + astKey);
            }
            // Filter出要被导出的
            for (let name in ast) {
                if (filter({
                    path: filepath,
                    name: name,
                    isExport: ast[name].isExport
                })) {
                    if (this.options.verbose) {
                        logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', 'generate', `filter passed: ${name} at ${filepath}`);
                    }
                    // 记入exports
                    if (!exports[filepath]) {
                        exports[filepath] = [];
                    }
                    exports[filepath].push(name);
                    // 加入output
                    await this._addToOutput(astKey, name, ast[name].schema, output, astCache, logger);
                }
                else if (this.options.verbose) {
                    logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', 'generate', `filter not passed: ${name} at ${filepath}`);
                }
            }
        }
        // Post process
        this._postHelper = new ProtoHelper(output);
        // Pre Pick/Omit keys
        this._astParser.pre.prePickOmitSchemas.forEach(v => {
            this._postPreKeys(v, options.logger);
        });
        this._astParser.pre.preEnumSchemas.forEach(v => {
            v.members.forEach(m => {
                delete m.name;
            });
        });
        // 重新生成EncodeId
        this._regenResultEncodeIds(output, options.compatibleResult);
        return output;
    }
    /**
     * 重新生成EncodeId
     * @param output
     * @param compatibleResult
     */
    _regenResultEncodeIds(output, compatibleResult) {
        for (let schemaId in output) {
            this._regenSchemaEncodeIds(output[schemaId], compatibleResult && compatibleResult[schemaId]);
        }
    }
    _regenSchemaEncodeIds(schema, compatibleSchema) {
        // 不仅要有 还要是同类型才行
        if (compatibleSchema && compatibleSchema.type !== schema.type) {
            compatibleSchema = undefined;
        }
        switch (schema.type) {
            case 'Enum': {
                let cpIds = EncodeIdUtil.getSchemaEncodeIds(compatibleSchema);
                let ids = EncodeIdUtil.genEncodeIds(EncodeIdUtil.getSchemaEncodeKeys(schema), cpIds);
                for (let i = 0; i < ids.length; ++i) {
                    schema.members[i].id = ids[i].id;
                }
                break;
            }
            case 'Interface': {
                // extends
                if (schema.extends) {
                    let cpExtends = compatibleSchema && compatibleSchema.extends;
                    let cpIds = cpExtends && cpExtends.map(v => ({
                        key: JSON.stringify(v.type),
                        id: v.id
                    }));
                    let ids = EncodeIdUtil.genEncodeIds(schema.extends.map(v => JSON.stringify(v.type)), cpIds);
                    for (let i = 0; i < ids.length; ++i) {
                        schema.extends[i].id = ids[i].id;
                    }
                }
                // properties
                if (schema.properties) {
                    let cpIds = EncodeIdUtil.getSchemaEncodeIds(compatibleSchema);
                    let ids = EncodeIdUtil.genEncodeIds(EncodeIdUtil.getSchemaEncodeKeys(schema), cpIds);
                    let cpSchemaProps = compatibleSchema && compatibleSchema.properties;
                    for (let i = 0; i < ids.length; ++i) {
                        // 更新ID
                        schema.properties[i].id = ids[i].id;
                        // 递归子项
                        let subCpProp = cpSchemaProps && cpSchemaProps.find(v => v.name === schema.properties[i].name);
                        this._regenSchemaEncodeIds(schema.properties[i].type, subCpProp ? subCpProp.type : undefined);
                    }
                }
                // indexSignature
                if (schema.indexSignature) {
                    let cpIndexSignature = compatibleSchema
                        && compatibleSchema.indexSignature
                        && compatibleSchema.indexSignature.type || undefined;
                    this._regenSchemaEncodeIds(schema.indexSignature.type, cpIndexSignature);
                }
                break;
            }
            case 'Intersection':
            case 'Union':
                let cpIds = EncodeIdUtil.getSchemaEncodeIds(compatibleSchema);
                let ids = EncodeIdUtil.genEncodeIds(EncodeIdUtil.getSchemaEncodeKeys(schema), cpIds);
                for (let i = 0; i < ids.length; ++i) {
                    schema.members[i].id = ids[i].id;
                    // 递归子项
                    let subCpMember = compatibleSchema
                        && compatibleSchema.members.find(v => v.id === ids[i].id);
                    let subCpSchema = subCpMember && subCpMember.type;
                    this._regenSchemaEncodeIds(schema.members[i].type, subCpSchema);
                }
                break;
            case 'Array':
                // TODO elementType
                this._regenSchemaEncodeIds(schema.elementType, compatibleSchema && compatibleSchema.elementType);
                break;
            case 'IndexedAccess':
                this._regenSchemaEncodeIds(schema.objectType, compatibleSchema && compatibleSchema.objectType);
                break;
            case 'Tuple':
                for (let i = 0; i < schema.elementTypes.length; ++i) {
                    this._regenSchemaEncodeIds(schema.elementTypes[i], compatibleSchema && compatibleSchema.elementTypes[i]);
                }
                break;
        }
    }
    async _getAst(pathOrKey, astCache, logger) {
        // GET AST KEY
        let astKey = pathOrKey.replace(/\\/g, '/').replace(/(\.d)?\.ts$/, '');
        if (!astCache[astKey]) {
            // 按node规则解析文件
            let fileContent;
            let postfixs = ['.ts', '.d.ts', '/index.ts', '/index.d.ts'];
            for (let postfix of postfixs) {
                try {
                    fileContent = await this.options.readFile(astKey + postfix);
                }
                // 出错 继续加载下一个
                catch (_a) {
                    continue;
                }
                // 未出错 说明解析到文件
                if (postfix.startsWith('/')) {
                    astKey = astKey + '/index';
                }
                break;
            }
            // 找不到文件，报错
            if (fileContent === undefined) {
                throw new Error(`Cannot resolve file: ` + path__default["default"].resolve(this.options.baseDir, astKey));
            }
            try {
                astCache[astKey] = this._astParser.parseScript(fileContent, logger);
            }
            catch (e) {
                if (e instanceof Error) {
                    e.message += `\n    at ${astKey}`;
                }
                throw e;
            }
        }
        return {
            ast: astCache[astKey],
            astKey: astKey
        };
    }
    async _addToOutput(astKey, name, schema, output, astCache, logger) {
        if (this.options.verbose) {
            logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', `addToOutput(${astKey}, ${name}})`);
        }
        let schemaId = astKey + '/' + name;
        if (output[schemaId]) {
            // Already added
            return;
        }
        output[schemaId] = schema;
        // 递归加入引用
        let refs = SchemaUtil.getUsedReferences(schema);
        if (this.options.verbose) {
            logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', `addToOutput(${astKey}, ${name}})`, `refs.length=${refs.length}`);
        }
        for (let ref of refs) {
            await this._addRefToOutput(ref, astKey, name, output, astCache, logger);
        }
    }
    /**
     * 追加引用到的依赖
     * @param ref 被依赖的 Schema
     * @param astKey 依赖主的 astKey
     * @param name 依赖主的 name
     * @param output 输出的 Proto
     * @param astCache AST Cache
     * @param logger Logger
     * @returns
     */
    async _addRefToOutput(ref, astKey, name, output, astCache, logger) {
        var _a;
        if ((_a = this.options.customSchemaIds) === null || _a === void 0 ? void 0 : _a.includes(ref.target)) {
            if (this.options.verbose) {
                logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', `Ignored Reference Target '${ref.target}'`);
            }
            ref.target = '?' + ref.target;
            return;
        }
        let refPath;
        // 外部引用
        let pathMatch = ref.target.match(/(.*)\/(.*)$/);
        if (pathMatch) {
            // 相对路径引用
            if (ref.target.startsWith('.')) {
                refPath = path__default["default"].join(astKey, '..', pathMatch[1]);
            }
            // 绝对路径引用 resolveModule
            else {
                if (!this.options.resolveModule) {
                    throw new Error(`Must specific a resolveModule handler for resolve '${pathMatch[1]}'`);
                }
                refPath = this.options.resolveModule(pathMatch[1], this.options.baseDir);
            }
        }
        // 当前文件内引用
        else {
            refPath = astKey;
        }
        if (this.options.verbose) {
            logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', `addToOutput(${astKey}, ${name}})`, `AST '${refPath}' loading`);
        }
        // load ast
        let refAst = await this._getAst(refPath, astCache, logger);
        if (this.options.verbose) {
            logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', `addToOutput(${astKey}, ${name}})`, `AST '${refPath}' loaded`);
        }
        // 将要挨个寻找的refTarget
        let refTargetNames = [];
        // 文件内&Namespace内引用，从Namespace向外部 逐级寻找
        if (!pathMatch && name.indexOf('.') > 0) {
            // name: A.B.C.D
            // refTarget: E
            // A.B.C.E
            // A.B.E
            // A.E
            // E
            let nameArr = name.split('.');
            for (let i = nameArr.length - 1; i >= 1; --i) {
                let refName = '';
                for (let j = 0; j < i; ++j) {
                    refName += `${nameArr[j]}.`;
                }
                refTargetNames.push(refName + ref.target);
            }
        }
        let refTargetName = pathMatch ? pathMatch[2] : ref.target;
        refTargetNames.push(refTargetName);
        // 确认的 refTargetName
        let certainRefTargetName;
        for (let refTargetName of refTargetNames) {
            if (refAst.ast[refTargetName]) {
                certainRefTargetName = refTargetName;
                break;
            }
        }
        if (this.options.verbose) {
            logger === null || logger === void 0 ? void 0 : logger.debug('[TSBuffer Schema Generator]', `addToOutput(${astKey}, ${name}})`, `refTargetName=${certainRefTargetName}`);
        }
        if (certainRefTargetName) {
            // 修改源reference的target
            ref.target = refAst.astKey + '/' + certainRefTargetName;
            // 将ref加入output
            await this._addToOutput(refAst.astKey, certainRefTargetName, refAst.ast[certainRefTargetName].schema, output, astCache, logger);
            return;
        }
        // TODO 可能是enum引用？
        let rMatch = refTargetName.match(/^(\w+)\.(\w+)$/);
        if (rMatch && refAst.ast[rMatch[1]]) {
            // enum schema
            let enumSchema = refAst.ast[rMatch[1]].schema;
            if (enumSchema.type === tsbufferSchema.SchemaType.Enum) {
                // add enum to output
                await this._addRefToOutput({
                    type: tsbufferSchema.SchemaType.Reference,
                    target: ref.target.substr(0, ref.target.length - rMatch[2].length - 1)
                }, astKey, name, output, astCache, logger);
                // replace ref to LiteralTypeSchema
                for (let key in ref) {
                    delete ref[key];
                }
                let member = enumSchema.members.find(v => v.name === rMatch[2]);
                if (!member) {
                    throw new Error('Referenced an unexisted enum key: ' + rMatch[2]);
                }
                Object.assign(ref, {
                    type: tsbufferSchema.SchemaType.Literal,
                    literal: member.value
                });
                return;
            }
        }
        logger === null || logger === void 0 ? void 0 : logger.debug('current', astKey, name);
        logger === null || logger === void 0 ? void 0 : logger.debug('ref', ref);
        throw new Error(`Cannot find reference target '${ref.target}'\n    at ${name}\n    at ${astKey}`);
    }
    _postPreKeys(schema, logger) {
        schema.keys = this._calcPreKey(schema.pre.key, logger);
        delete schema.pre;
    }
    _calcPreKey(schema, logger) {
        // Nested pre key
        if ((schema.type === tsbufferSchema.SchemaType.Pick || schema.type === tsbufferSchema.SchemaType.Omit) && schema.pre) {
            return this._calcPreKey(schema.pre.key, logger);
        }
        // Type Reference
        if (this._astParser['_isTypeReference'](schema)) {
            return this._calcPreKey(this._postHelper.parseReference(schema), logger);
        }
        switch (schema.type) {
            case tsbufferSchema.SchemaType.Union:
                return schema.members.map(v => this._calcPreKey(v.type, logger)).reduce((prev, next) => prev.concat(next), []).distinct();
            case tsbufferSchema.SchemaType.Intersection:
                return schema.members.map(v => this._calcPreKey(v.type, logger)).reduce((prev, next) => prev.filter(v => next.indexOf(v) > -1));
            case tsbufferSchema.SchemaType.Literal:
                return ['' + schema.literal];
        }
        logger === null || logger === void 0 ? void 0 : logger.log('Illeagle type of key:', schema);
        throw new Error('Illeagle type of key: ' + JSON.stringify(schema, null, 2));
    }
}
const defaultResolveModule = (importPath, baseDir) => path__default["default"].join('node_modules', importPath);

exports.EncodeIdUtil = EncodeIdUtil;
exports.TSBufferProtoGenerator = ProtoGenerator;
