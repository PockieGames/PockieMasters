/*!
 * TSRPC v3.3.0
 * -----------------------------------------
 * Copyright (c) King Wang.
 * MIT License
 * https://github.com/k8w/tsrpc
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('k8w-extend-native');
var tsrpcBaseClient = require('tsrpc-base-client');
var tsrpcProto = require('tsrpc-proto');
var bson = require('bson');
var http = require('http');
var https = require('https');
var WebSocket = require('ws');
var chalk = require('chalk');
var path = require('path');
var tsbuffer = require('tsbuffer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
var http__namespace = /*#__PURE__*/_interopNamespace(http);
var https__default = /*#__PURE__*/_interopDefaultLegacy(https);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);
var WebSocket__namespace = /*#__PURE__*/_interopNamespace(WebSocket);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var path__namespace = /*#__PURE__*/_interopNamespace(path);

/** @internal */
class HttpProxy {
    fetch(options) {
        let nodeHttp = options.url.startsWith('https://') ? https__default["default"] : http__default["default"];
        let rs;
        let promise = new Promise(_rs => {
            rs = _rs;
        });
        let httpReq;
        httpReq = nodeHttp.request(options.url, {
            method: options.method,
            agent: this.agent,
            timeout: options.timeout,
            headers: options.headers,
        }, httpRes => {
            let data = [];
            httpRes.on('data', (v) => {
                data.push(v);
            });
            httpRes.on('end', () => {
                let buf = Buffer.concat(data);
                if (options.responseType === 'text') {
                    rs({
                        isSucc: true,
                        res: buf.toString()
                    });
                }
                else {
                    rs({
                        isSucc: true,
                        res: buf
                    });
                }
            });
        });
        httpReq.on('error', e => {
            rs({
                isSucc: false,
                err: new tsrpcProto.TsrpcError(e.message, {
                    type: tsrpcProto.TsrpcError.Type.NetworkError,
                    code: e.code
                })
            });
        });
        let buf = options.data;
        httpReq.end(typeof buf === 'string' ? buf : Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
        let abort = httpReq.abort.bind(httpReq);
        return {
            promise: promise,
            abort: abort
        };
    }
}

/**
 * Client for TSRPC HTTP Server.
 * It uses native http module of NodeJS.
 * @typeParam ServiceType - `ServiceType` from generated `proto.ts`
 */
class HttpClient extends tsrpcBaseClient.BaseHttpClient {
    constructor(proto, options) {
        let httpProxy = new HttpProxy;
        super(proto, httpProxy, {
            customObjectIdClass: bson.ObjectId,
            ...defaultHttpClientOptions,
            ...options
        });
        httpProxy.agent = this.options.agent;
    }
}
const defaultHttpClientOptions = {
    ...tsrpcBaseClient.defaultBaseHttpClientOptions
};

/**
 * @internal
 */
class WebSocketProxy {
    connect(server, protocols) {
        this._ws = new WebSocket__default["default"](server, protocols);
        this._ws.onopen = this.options.onOpen;
        this._ws.onclose = e => {
            this.options.onClose(e.code, e.reason);
            this._ws = undefined;
        };
        this._ws.onerror = e => {
            this.options.onError(e.error);
        };
        this._ws.onmessage = e => {
            if (e.data instanceof ArrayBuffer) {
                this.options.onMessage(new Uint8Array(e.data));
            }
            else if (Array.isArray(e.data)) {
                this.options.onMessage(Buffer.concat(e.data));
            }
            else {
                this.options.onMessage(e.data);
            }
        };
    }
    close(code, reason) {
        var _a;
        (_a = this._ws) === null || _a === void 0 ? void 0 : _a.close(code, reason);
        this._ws = undefined;
    }
    send(data) {
        return new Promise(rs => {
            var _a;
            (_a = this._ws) === null || _a === void 0 ? void 0 : _a.send(data, err => {
                var _a;
                if (err) {
                    (_a = this.options.logger) === null || _a === void 0 ? void 0 : _a.error('WebSocket Send Error:', err);
                    rs({
                        err: new tsrpcProto.TsrpcError('Network Error', {
                            code: 'SEND_BUF_ERR',
                            type: tsrpcProto.TsrpcError.Type.NetworkError,
                            innerErr: err
                        })
                    });
                    return;
                }
                rs({});
            });
        });
    }
}

/**
 * Client for TSRPC WebSocket Server.
 * @typeParam ServiceType - `ServiceType` from generated `proto.ts`
 */
class WsClient extends tsrpcBaseClient.BaseWsClient {
    constructor(proto, options) {
        let wsp = new WebSocketProxy();
        super(proto, wsp, {
            customObjectIdClass: bson.ObjectId,
            ...defaultWsClientOptions,
            ...options
        });
    }
}
const defaultWsClientOptions = {
    ...tsrpcBaseClient.defaultBaseWsClientOptions,
};

/** Version of TSRPC */
const TSRPC_VERSION = '3.3.0';

/**
 * Auto add prefix using existed `Logger`
 */
class PrefixLogger {
    constructor(options) {
        this.logger = options.logger;
        this.prefixs = options.prefixs;
    }
    getPrefix() {
        return this.prefixs.map(v => typeof v === 'string' ? v : v());
    }
    log(...args) {
        this.logger.log(...this.getPrefix().concat(args));
    }
    debug(...args) {
        this.logger.debug(...this.getPrefix().concat(args));
    }
    warn(...args) {
        this.logger.warn(...this.getPrefix().concat(args));
    }
    error(...args) {
        this.logger.error(...this.getPrefix().concat(args));
    }
}

class BaseCall {
    constructor(options, logger) {
        this.conn = options.conn;
        this.service = options.service;
        this.startTime = Date.now();
        this.logger = logger;
    }
    get server() {
        return this.conn.server;
    }
}

/**
 * A call request by `client.callApi()`
 * @typeParam Req - Type of request
 * @typeParam Res - Type of response
 * @typeParam ServiceType - The same `ServiceType` to server, it is used for code auto hint.
 */
class ApiCall extends BaseCall {
    constructor(options, logger) {
        super(options, logger !== null && logger !== void 0 ? logger : new PrefixLogger({
            logger: options.conn.logger,
            prefixs: [`[Api:${options.service.name}]${options.sn !== undefined ? ` SN=${options.sn}` : ''}`]
        }));
        this.type = 'api';
        this.sn = options.sn;
        this.req = options.req;
    }
    /**
     * Response Data that sent already.
     * `undefined` means no return data is sent yet. (Never `call.succ()` and `call.error()`)
     */
    get return() {
        return this._return;
    }
    /** Time from received req to send return data */
    get usedTime() {
        return this._usedTime;
    }
    /**
     * Send a successful `ApiReturn` with response data
     * @param res - Response data
     * @returns Promise resolved means the buffer is sent to kernel
     */
    succ(res) {
        return this._prepareReturn({
            isSucc: true,
            res: res
        });
    }
    error(errOrMsg, data) {
        let error = typeof errOrMsg === 'string' ? new tsrpcProto.TsrpcError(errOrMsg, data) : errOrMsg;
        return this._prepareReturn({
            isSucc: false,
            err: error
        });
    }
    ;
    async _prepareReturn(ret) {
        if (this._return) {
            return;
        }
        this._return = ret;
        // Pre Flow
        let preFlow = await this.server.flows.preApiReturnFlow.exec({ call: this, return: ret }, this.logger);
        // Stopped!
        if (!preFlow) {
            this.logger.debug('[preApiReturnFlow]', 'Canceled');
            return;
        }
        ret = preFlow.return;
        // record & log ret
        this._usedTime = Date.now() - this.startTime;
        if (ret.isSucc) {
            this.logger.log('[ApiRes]', `${this.usedTime}ms`, this.server.options.logResBody ? ret.res : '');
        }
        else {
            if (ret.err.type === tsrpcProto.TsrpcErrorType.ApiError) {
                this.logger.log('[ApiErr]', `${this.usedTime}ms`, ret.err, 'req=', this.req);
            }
            else {
                this.logger.error(`[ApiErr]`, `${this.usedTime}ms`, ret.err, 'req=', this.req);
            }
        }
        // Do send!
        this._return = ret;
        let opSend = await this._sendReturn(ret);
        if (!opSend.isSucc) {
            if (opSend.canceledByFlow) {
                this.logger.debug(`[${opSend.canceledByFlow}]`, 'Canceled');
            }
            else {
                this.logger.error('[SendDataErr]', opSend.errMsg);
                if (ret.isSucc || ret.err.type === tsrpcProto.TsrpcErrorType.ApiError) {
                    this._return = undefined;
                    this.server.onInternalServerError({ message: opSend.errMsg, name: 'SendReturnErr' }, this);
                }
            }
            return;
        }
        // Post Flow
        await this.server.flows.postApiReturnFlow.exec(preFlow, this.logger);
    }
    async _sendReturn(ret) {
        // Encode
        let opServerOutput = ApiCall.encodeApiReturn(this.server.tsbuffer, this.service, ret, this.conn.dataType, this.sn);
        if (!opServerOutput.isSucc) {
            this.server.onInternalServerError({ message: opServerOutput.errMsg, stack: '  |- TransportDataUtil.encodeApiReturn\n  |- ApiCall._sendReturn' }, this);
            return opServerOutput;
        }
        let opSend = await this.conn.sendData(opServerOutput.output);
        if (!opSend.isSucc) {
            return opSend;
        }
        return opSend;
    }
    static encodeApiReturn(tsbuffer, service, apiReturn, type, sn) {
        if (type === 'buffer') {
            let serverOutputData = {
                sn: sn,
                serviceId: sn !== undefined ? service.id : undefined
            };
            if (apiReturn.isSucc) {
                let op = tsbuffer.encode(apiReturn.res, service.resSchemaId);
                if (!op.isSucc) {
                    return op;
                }
                serverOutputData.buffer = op.buf;
            }
            else {
                serverOutputData.error = apiReturn.err;
            }
            let op = tsrpcBaseClient.TransportDataUtil.tsbuffer.encode(serverOutputData, 'ServerOutputData');
            return op.isSucc ? { isSucc: true, output: op.buf } : { isSucc: false, errMsg: op.errMsg };
        }
        else {
            apiReturn = { ...apiReturn };
            if (apiReturn.isSucc) {
                let op = tsbuffer.encodeJSON(apiReturn.res, service.resSchemaId);
                if (!op.isSucc) {
                    return op;
                }
                apiReturn.res = op.json;
            }
            else {
                apiReturn.err = {
                    ...apiReturn.err
                };
            }
            let json = sn == undefined ? apiReturn : [service.name, apiReturn, sn];
            return { isSucc: true, output: type === 'json' ? json : JSON.stringify(json) };
        }
    }
}

class BaseConnection {
    constructor(options, logger) {
        this.id = options.id;
        this.ip = options.ip;
        this.server = options.server;
        this.logger = logger;
        this.dataType = options.dataType;
    }
    /** Send buffer (with pre-flow and post-flow) */
    async sendData(data, call) {
        var _a, _b, _c, _d, _e, _f;
        // Pre Flow
        let pre = await this.server.flows.preSendDataFlow.exec({ conn: this, data: data, call: call }, (call === null || call === void 0 ? void 0 : call.logger) || this.logger);
        if (!pre) {
            return { isSucc: false, errMsg: 'Canceled by preSendDataFlow', canceledByFlow: 'preSendDataFlow' };
        }
        data = pre.data;
        // @deprecated Pre Buffer Flow
        if (data instanceof Uint8Array) {
            let preBuf = await this.server.flows.preSendBufferFlow.exec({ conn: this, buf: data, call: call }, (call === null || call === void 0 ? void 0 : call.logger) || this.logger);
            if (!preBuf) {
                return { isSucc: false, errMsg: 'Canceled by preSendBufferFlow', canceledByFlow: 'preSendBufferFlow' };
            }
            data = preBuf.buf;
        }
        // debugBuf log
        if (this.server.options.debugBuf) {
            if (typeof data === 'string') {
                (_b = ((_a = call === null || call === void 0 ? void 0 : call.logger) !== null && _a !== void 0 ? _a : this.logger)) === null || _b === void 0 ? void 0 : _b.debug(`[SendText] length=${data.length}`, data);
            }
            else if (data instanceof Uint8Array) {
                (_d = ((_c = call === null || call === void 0 ? void 0 : call.logger) !== null && _c !== void 0 ? _c : this.logger)) === null || _d === void 0 ? void 0 : _d.debug(`[SendBuf] length=${data.length}`, data);
            }
            else {
                (_f = ((_e = call === null || call === void 0 ? void 0 : call.logger) !== null && _e !== void 0 ? _e : this.logger)) === null || _f === void 0 ? void 0 : _f.debug('[SendJSON]', data);
            }
        }
        return this.doSendData(data, call);
    }
    makeCall(input) {
        if (input.type === 'api') {
            return new this.ApiCallClass({
                conn: this,
                service: input.service,
                req: input.req,
                sn: input.sn,
            });
        }
        else {
            return new this.MsgCallClass({
                conn: this,
                service: input.service,
                msg: input.msg
            });
        }
    }
    /**
     * Send message to the client, only be available when it is long connection.
     * @param msgName
     * @param msg - Message body
     * @returns Promise resolved when the buffer is sent to kernel, it not represents the server received it.
     */
    async sendMsg(msgName, msg) {
        if (this.type === 'SHORT') {
            this.logger.warn('[SendMsgErr]', `[${msgName}]`, 'Short connection cannot sendMsg');
            return { isSucc: false, errMsg: 'Short connection cannot sendMsg' };
        }
        let service = this.server.serviceMap.msgName2Service[msgName];
        if (!service) {
            this.logger.warn('[SendMsgErr]', `[${msgName}]`, `Invalid msg name: ${msgName}`);
            return { isSucc: false, errMsg: `Invalid msg name: ${msgName}` };
        }
        // Pre Flow
        let pre = await this.server.flows.preSendMsgFlow.exec({ conn: this, service: service, msg: msg }, this.logger);
        if (!pre) {
            this.logger.debug('[preSendMsgFlow]', 'Canceled');
            return { isSucc: false, errMsg: 'Canceled by preSendMsgFlow', canceledByFlow: 'preSendMsgFlow' };
        }
        msg = pre.msg;
        // Encode
        let opServerOutput = tsrpcBaseClient.TransportDataUtil.encodeServerMsg(this.server.tsbuffer, service, msg, this.dataType, this.type);
        if (!opServerOutput.isSucc) {
            this.logger.warn('[SendMsgErr]', `[${msgName}]`, opServerOutput.errMsg);
            return opServerOutput;
        }
        // Do send!
        this.server.options.logMsg && this.logger.log('[SendMsg]', `[${msgName}]`, msg);
        let opSend = await this.sendData(opServerOutput.output);
        if (!opSend.isSucc) {
            return opSend;
        }
        // Post Flow
        await this.server.flows.postSendMsgFlow.exec(pre, this.logger);
        return { isSucc: true };
    }
    /**
     * Add a message handler,
     * duplicate handlers to the same `msgName` would be ignored.
     * @param msgName
     * @param handler
     */
    listenMsg(msgName, handler) {
        if (!this._msgHandlers) {
            this._msgHandlers = new tsrpcBaseClient.MsgHandlerManager();
        }
        this._msgHandlers.addHandler(msgName, handler);
        return handler;
    }
    ;
    /**
     * Remove a message handler
     */
    unlistenMsg(msgName, handler) {
        if (!this._msgHandlers) {
            this._msgHandlers = new tsrpcBaseClient.MsgHandlerManager();
        }
        this._msgHandlers.removeHandler(msgName, handler);
    }
    ;
    /**
     * Remove all handlers from a message
     */
    unlistenMsgAll(msgName) {
        if (!this._msgHandlers) {
            this._msgHandlers = new tsrpcBaseClient.MsgHandlerManager();
        }
        this._msgHandlers.removeAllHandlers(msgName);
    }
    ;
}
exports.ConnectionStatus = void 0;
(function (ConnectionStatus) {
    ConnectionStatus["Opened"] = "OPENED";
    ConnectionStatus["Closing"] = "CLOSING";
    ConnectionStatus["Closed"] = "CLOSED";
})(exports.ConnectionStatus || (exports.ConnectionStatus = {}));

class ApiCallInner extends ApiCall {
    constructor(options) {
        super(options);
    }
    async _sendReturn(ret) {
        if (this.conn.return.type === 'raw') {
            // Validate Res
            if (ret.isSucc) {
                let resValidate = this.server.tsbuffer.validate(ret.res, this.service.resSchemaId);
                if (!resValidate.isSucc) {
                    return resValidate;
                }
            }
            return this.conn.sendData(ret);
        }
        return super._sendReturn(ret);
    }
}

/**
 * Server can `callApi` it self by using this inner connection
 */
class InnerConnection extends BaseConnection {
    constructor(options) {
        super(options, new PrefixLogger({
            logger: options.server.logger,
            prefixs: [`Inner #${options.id}`]
        }));
        this.type = 'SHORT';
        this.ApiCallClass = ApiCallInner;
        this.MsgCallClass = null;
        this._status = exports.ConnectionStatus.Opened;
        this.return = options.return;
    }
    get status() {
        return this._status;
    }
    close(reason) {
        this.doSendData({
            isSucc: false,
            err: new tsrpcProto.TsrpcError(reason !== null && reason !== void 0 ? reason : 'Internal Server Error', {
                type: tsrpcProto.TsrpcErrorType.ServerError,
                code: 'CONN_CLOSED',
                reason: reason
            })
        });
    }
    async doSendData(data, call) {
        this._status = exports.ConnectionStatus.Closed;
        if (this.return.type === 'buffer') {
            if (!(data instanceof Uint8Array)) {
                // encode tsrpc error
                if (!data.isSucc) {
                    let op = tsrpcBaseClient.TransportDataUtil.tsbuffer.encode({
                        error: data.err
                    }, 'ServerOutputData');
                    if (op.isSucc) {
                        return this.doSendData(op.buf, call);
                    }
                }
                return { isSucc: false, errMsg: 'Error data type' };
            }
            this.return.rs(data);
            return { isSucc: true };
        }
        else {
            if (data instanceof Uint8Array) {
                return { isSucc: false, errMsg: 'Error data type' };
            }
            this.return.rs(data);
            return { isSucc: true };
        }
    }
}

/**
 * Print log to terminal, with color.
 */
class TerminalColorLogger {
    constructor(options) {
        this.options = {
            pid: process.pid.toString(),
            timeFormat: 'yyyy-MM-dd hh:mm:ss'
        };
        Object.assign(this.options, options);
        this._pid = this.options.pid ? `<${this.options.pid}> ` : '';
    }
    _time() {
        return this.options.timeFormat ? new Date().format(this.options.timeFormat) : '';
    }
    debug(...args) {
        console.debug.call(console, chalk__default["default"].gray(`${this._pid}${this._time()}`), chalk__default["default"].cyan('[DEBUG]'), ...args);
    }
    log(...args) {
        console.log.call(console, chalk__default["default"].gray(`${this._pid}${this._time()}`), chalk__default["default"].green('[INFO]'), ...args);
    }
    warn(...args) {
        console.warn.call(console, chalk__default["default"].gray(`${this._pid}${this._time()}`), chalk__default["default"].yellow('[WARN]'), ...args);
    }
    error(...args) {
        console.error.call(console, chalk__default["default"].gray(`${this._pid}${this._time()}`), chalk__default["default"].red('[ERROR]'), ...args);
    }
}

/**
 * Abstract base class for TSRPC Server.
 * Implement on a transportation protocol (like HTTP WebSocket) by extend it.
 * @typeParam ServiceType - `ServiceType` from generated `proto.ts`
 */
class BaseServer {
    constructor(proto, options) {
        this._status = exports.ServerStatus.Closed;
        this._connIdCounter = new tsrpcBaseClient.Counter(1);
        /**
         * Flow is a specific concept created by TSRPC family.
         * All pre-flow can interrupt latter behaviours.
         * All post-flow can NOT interrupt latter behaviours.
         */
        this.flows = {
            // Conn Flows
            /** After the connection is created */
            postConnectFlow: new tsrpcBaseClient.Flow(),
            /** After the connection is disconnected */
            postDisconnectFlow: new tsrpcBaseClient.Flow(),
            // Buffer Flows
            /**
             * Before processing the received data, usually be used to encryption / decryption.
             * Return `null | undefined` would ignore the buffer.
             */
            preRecvDataFlow: new tsrpcBaseClient.Flow(),
            /**
             * Before send out data to network, usually be used to encryption / decryption.
             * Return `null | undefined` would not send the buffer.
             */
            preSendDataFlow: new tsrpcBaseClient.Flow(),
            /**
             * @deprecated Use `preRecvDataFlow` instead.
             */
            preRecvBufferFlow: new tsrpcBaseClient.Flow(),
            /**
             * @deprecated Use `preSendDataFlow` instead.
             */
            preSendBufferFlow: new tsrpcBaseClient.Flow(),
            // ApiCall Flows
            /**
             * Before a API request is send.
             * Return `null | undefined` would cancel the request.
             */
            preApiCallFlow: new tsrpcBaseClient.Flow(),
            /**
             * Before return the `ApiReturn` to the client.
             * It may be used to change the return value, or return `null | undefined` to abort the request.
             */
            preApiReturnFlow: new tsrpcBaseClient.Flow(),
            /**
             * After the `ApiReturn` is send.
             * return `null | undefined` would NOT interrupt latter behaviours.
             */
            postApiReturnFlow: new tsrpcBaseClient.Flow(),
            /**
             * After the api handler is executed.
             * return `null | undefined` would NOT interrupt latter behaviours.
             */
            postApiCallFlow: new tsrpcBaseClient.Flow(),
            // MsgCall Flows
            /**
             * Before handle a `MsgCall`
             */
            preMsgCallFlow: new tsrpcBaseClient.Flow(),
            /**
             * After handlers of a `MsgCall` are executed.
             * return `null | undefined` would NOT interrupt latter behaviours.
             */
            postMsgCallFlow: new tsrpcBaseClient.Flow(),
            /**
             * Before send out a message.
             * return `null | undefined` would NOT interrupt latter behaviours.
             */
            preSendMsgFlow: new tsrpcBaseClient.Flow(),
            /**
             * After send out a message.
             * return `null | undefined` would NOT interrupt latter behaviours.
             */
            postSendMsgFlow: new tsrpcBaseClient.Flow(),
        };
        // Handlers
        this._apiHandlers = {};
        // 多个Handler将异步并行执行
        this._msgHandlers = new tsrpcBaseClient.MsgHandlerManager();
        this._pendingApiCallNum = 0;
        this.proto = proto;
        this.options = options;
        // @deprecated jsonEnabled
        if (this.options.json) {
            this.options.jsonEnabled = true;
        }
        this.tsbuffer = new tsbuffer.TSBuffer({
            ...proto.types,
            // Support mongodb/ObjectId
            ...tsrpcBaseClient.getCustomObjectIdTypes(bson.ObjectId)
        }, {
            strictNullChecks: this.options.strictNullChecks
        });
        this.serviceMap = tsrpcBaseClient.ServiceMapUtil.getServiceMap(proto);
        this.logger = this.options.logger;
        tsrpcProto.setLogLevel(this.logger, this.options.logLevel);
        // Process uncaught exception, so that Node.js process would not exit easily
        BaseServer.processUncaughtException(this.logger);
        // default flows onError handler
        this._setDefaultFlowOnError();
    }
    get status() {
        return this._status;
    }
    /**
     * It makes the `uncaughtException` and `unhandledRejection` not lead to the server stopping.
     * @param logger
     * @returns
     */
    static processUncaughtException(logger) {
        if (this._isUncaughtExceptionProcessed) {
            return;
        }
        this._isUncaughtExceptionProcessed = true;
        process.on('uncaughtException', e => {
            logger.error('[uncaughtException]', e);
        });
        process.on('unhandledRejection', e => {
            logger.error('[unhandledRejection]', e);
        });
    }
    _setDefaultFlowOnError() {
        // API Flow Error: return [InternalServerError]
        this.flows.preApiCallFlow.onError = (e, call) => {
            if (e instanceof tsrpcProto.TsrpcError) {
                call.error(e);
            }
            else {
                this.onInternalServerError(e, call);
            }
        };
        this.flows.postApiCallFlow.onError = (e, call) => {
            if (!call.return) {
                if (e instanceof tsrpcProto.TsrpcError) {
                    call.error(e);
                }
                else {
                    this.onInternalServerError(e, call);
                }
            }
            else {
                call.logger.error('postApiCallFlow Error:', e);
            }
        };
        this.flows.preApiReturnFlow.onError = (e, last) => {
            last.call['_return'] = undefined;
            if (e instanceof tsrpcProto.TsrpcError) {
                last.call.error(e);
            }
            else {
                this.onInternalServerError(e, last.call);
            }
        };
        this.flows.postApiReturnFlow.onError = (e, last) => {
            if (!last.call.return) {
                if (e instanceof tsrpcProto.TsrpcError) {
                    last.call.error(e);
                }
                else {
                    this.onInternalServerError(e, last.call);
                }
            }
        };
    }
    // #region receive buffer process flow
    /**
     * Process the buffer, after the `preRecvBufferFlow`.
     */
    async _onRecvData(conn, data, serviceName) {
        var _a, _b, _c;
        // 非 OPENED 状态 停止接受新的请求
        if (!(conn instanceof InnerConnection) && this.status !== exports.ServerStatus.Opened) {
            return;
        }
        // debugBuf log
        if (this.options.debugBuf) {
            if (typeof data === 'string') {
                (_a = conn.logger) === null || _a === void 0 ? void 0 : _a.debug(`[RecvText] length=${data.length}`, data);
            }
            else if (data instanceof Uint8Array) {
                (_b = conn.logger) === null || _b === void 0 ? void 0 : _b.debug(`[RecvBuf] length=${data.length}`, data);
            }
            else {
                (_c = conn.logger) === null || _c === void 0 ? void 0 : _c.debug('[RecvJSON]', data);
            }
        }
        // jsonEnabled 未启用，不支持文本请求
        if (typeof data === 'string' && !this.options.jsonEnabled) {
            this.onInputDataError('JSON mode is not enabled, please use binary instead.', conn, data);
            return;
        }
        let pre = await this.flows.preRecvDataFlow.exec({ conn: conn, data: data, serviceName: serviceName }, conn.logger);
        if (!pre) {
            conn.logger.debug('[preRecvDataFlow] Canceled');
            return;
        }
        data = pre.data;
        serviceName = pre.serviceName;
        // @deprecated preRecvBuffer
        if (data instanceof Uint8Array) {
            let preBuf = await this.flows.preRecvBufferFlow.exec({ conn: conn, buf: data }, conn.logger);
            if (!preBuf) {
                conn.logger.debug('[preRecvBufferFlow] Canceled');
                return;
            }
            data = preBuf.buf;
        }
        // Parse Call
        let opInput = this._parseServerInput(this.tsbuffer, this.serviceMap, data, serviceName);
        if (!opInput.isSucc) {
            this.onInputDataError(opInput.errMsg, conn, data);
            return;
        }
        let call = conn.makeCall(opInput.result);
        if (call.type === 'api') {
            await this._handleApiCall(call);
        }
        else {
            await this._onMsgCall(call);
        }
    }
    async _handleApiCall(call) {
        var _a;
        ++this._pendingApiCallNum;
        await this._onApiCall(call);
        if (--this._pendingApiCallNum === 0) {
            (_a = this._gracefulStop) === null || _a === void 0 ? void 0 : _a.rs();
        }
    }
    async _onApiCall(call) {
        let timeoutTimer = this.options.apiTimeout ? setTimeout(() => {
            if (!call.return) {
                call.error('Server Timeout', {
                    code: 'SERVER_TIMEOUT',
                    type: tsrpcProto.TsrpcErrorType.ServerError
                });
            }
            timeoutTimer = undefined;
        }, this.options.apiTimeout) : undefined;
        // Pre Flow
        let preFlow = await this.flows.preApiCallFlow.exec(call, call.logger);
        if (!preFlow) {
            if (timeoutTimer) {
                clearTimeout(timeoutTimer);
                timeoutTimer = undefined;
            }
            call.logger.debug('[preApiCallFlow] Canceled');
            return;
        }
        call = preFlow;
        // exec ApiCall
        call.logger.log('[ApiReq]', this.options.logReqBody ? call.req : '');
        let { handler } = await this.getApiHandler(call.service, this._delayImplementApiPath, call.logger);
        // exec API handler
        if (handler) {
            try {
                await handler(call);
            }
            catch (e) {
                if (e instanceof tsrpcProto.TsrpcError) {
                    call.error(e);
                }
                else {
                    this.onInternalServerError(e, call);
                }
            }
        }
        // 未找到ApiHandler，且未进行任何输出
        else {
            call.error(`Unhandled API: ${call.service.name}`, { code: 'UNHANDLED_API', type: tsrpcProto.TsrpcErrorType.ServerError });
        }
        // Post Flow
        await this.flows.postApiCallFlow.exec(call, call.logger);
        if (timeoutTimer) {
            clearTimeout(timeoutTimer);
            timeoutTimer = undefined;
        }
        // Destroy call
        // if (!call.return) {
        //     this.onInternalServerError({ message: 'API not return anything' }, call);
        // }
    }
    async _onMsgCall(call) {
        var _a, _b;
        // 收到Msg即可断开连接（短连接）
        if (call.conn.type === 'SHORT') {
            call.conn.close();
        }
        // Pre Flow
        let preFlow = await this.flows.preMsgCallFlow.exec(call, call.logger);
        if (!preFlow) {
            call.logger.debug('[preMsgCallFlow]', 'Canceled');
            return;
        }
        call = preFlow;
        // MsgHandler
        this.options.logMsg && call.logger.log('[RecvMsg]', call.msg);
        let promises = [
            // Conn Handlers
            ...((_b = (_a = call.conn['_msgHandlers']) === null || _a === void 0 ? void 0 : _a.forEachHandler(call.service.name, call.logger, call)) !== null && _b !== void 0 ? _b : []),
            // Server Handlers
            this._msgHandlers.forEachHandler(call.service.name, call.logger, call)
        ];
        if (!promises.length) {
            this.logger.debug('[UNHANDLED_MSG]', call.service.name);
        }
        else {
            await Promise.all(promises);
        }
        // Post Flow
        await this.flows.postMsgCallFlow.exec(call, call.logger);
    }
    // #endregion    
    // #region Api/Msg handler register
    /**
     * Associate a `ApiHandler` to a specific `apiName`.
     * So that when `ApiCall` is receiving, it can be handled correctly.
     * @param apiName
     * @param handler
     */
    implementApi(apiName, handler) {
        if (this._apiHandlers[apiName]) {
            throw new Error('Already exist handler for API: ' + apiName);
        }
        this._apiHandlers[apiName] = handler;
        this.logger.log(`API implemented succ: [${apiName}]`);
    }
    ;
    /**
     * Auto call `imeplementApi` by traverse the `apiPath` and find all matched `PtlXXX` and `ApiXXX`.
     * It is matched by checking whether the relative path and name of an API is consistent to the service name in `serviceProto`.
     * Notice that the name prefix of protocol is `Ptl`, of API is `Api`.
     * For example, `protocols/a/b/c/PtlTest` is matched to `api/a/b/c/ApiTest`.
     * @param apiPath Absolute path or relative path to `process.cwd()`.
     * @returns
     */
    async autoImplementApi(apiPath, delay) {
        let apiServices = Object.values(this.serviceMap.apiName2Service);
        let output = { succ: [], fail: [] };
        if (delay) {
            this._delayImplementApiPath = apiPath;
            return output;
        }
        for (let svc of apiServices) {
            //get api handler
            let { handler } = await this.getApiHandler(svc, apiPath, this.logger);
            if (!handler) {
                output.fail.push(svc.name);
                continue;
            }
            this.implementApi(svc.name, handler);
            output.succ.push(svc.name);
        }
        if (output.fail.length) {
            this.logger.error(chalk__default["default"].red(`${output.fail.length} API implemented failed: ` + output.fail.map(v => chalk__default["default"].cyan.underline(v)).join(' ')));
        }
        return output;
    }
    async getApiHandler(svc, apiPath, logger) {
        var _a;
        if (this._apiHandlers[svc.name]) {
            return { handler: this._apiHandlers[svc.name] };
        }
        if (!apiPath) {
            return { errMsg: `Api not implemented: ${svc.name}` };
        }
        // get api last name
        let match = svc.name.match(/^(.+\/)*(.+)$/);
        if (!match) {
            logger === null || logger === void 0 ? void 0 : logger.error('Invalid apiName: ' + svc.name);
            return { errMsg: `Invalid api name: ${svc.name}` };
        }
        let handlerPath = match[1] || '';
        let handlerName = match[2];
        // try import
        let modulePath = path__namespace.resolve(apiPath, handlerPath, 'Api' + handlerName);
        try {
            var handlerModule = await (function (t) { return Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require(t)); }); })(modulePath);
        }
        catch (e) {
            this.logger.error(chalk__default["default"].red(`Implement API ${chalk__default["default"].cyan.underline(`${svc.name}`)} failed:`), e);
            return { errMsg: e.message };
        }
        // 优先 default，其次 ApiName 同名
        let handler = (_a = handlerModule.default) !== null && _a !== void 0 ? _a : handlerModule['Api' + handlerName];
        if (handler) {
            return { handler: handler };
        }
        else {
            return { errMsg: `Missing 'export Api${handlerName}' or 'export default' in: ${modulePath}` };
        }
    }
    /**
     * Add a message handler,
     * duplicate handlers to the same `msgName` would be ignored.
     * @param msgName
     * @param handler
     */
    listenMsg(msgName, handler) {
        this._msgHandlers.addHandler(msgName, handler);
        return handler;
    }
    ;
    /**
     * Remove a message handler
     */
    unlistenMsg(msgName, handler) {
        this._msgHandlers.removeHandler(msgName, handler);
    }
    ;
    /**
     * Remove all handlers from a message
     */
    unlistenMsgAll(msgName) {
        this._msgHandlers.removeAllHandlers(msgName);
    }
    ;
    // #endregion   
    /**
     * Event when the server cannot parse input buffer to api/msg call.
     * By default, it will return "Input Data Error" .
     */
    async onInputDataError(errMsg, conn, data) {
        if (this.options.debugBuf) {
            if (typeof data === 'string') {
                conn.logger.error(`[InputDataError] ${errMsg} length = ${data.length}`, data);
            }
            else if (data instanceof Uint8Array) {
                conn.logger.error(`[InputBufferError] ${errMsg} length = ${data.length}`, data.subarray(0, 16));
            }
            else {
                conn.logger.error(`[InputJsonError] ${errMsg} `, data);
            }
        }
        const message = data instanceof Uint8Array ? `Invalid request buffer, please check the version of service proto.` : errMsg;
        // Short conn, send apiReturn with error
        if (conn.type === 'SHORT') {
            // Return API Error
            let opEncode = ApiCall.encodeApiReturn(this.tsbuffer, {
                type: 'api',
                name: '?',
                id: 0,
                reqSchemaId: '?',
                resSchemaId: '?'
            }, {
                isSucc: false,
                err: new tsrpcProto.TsrpcError({
                    message: message,
                    type: tsrpcProto.TsrpcErrorType.ServerError,
                    code: 'INPUT_DATA_ERR'
                })
            }, conn.dataType);
            if (opEncode.isSucc) {
                let opSend = await conn.sendData(opEncode.output);
                if (opSend.isSucc) {
                    return;
                }
            }
        }
        conn.close(message);
    }
    /**
     * Event when a uncaught error (except `TsrpcError`) is throwed.
     * By default, it will return a `TsrpcError` with message "Internal server error".
     * If `returnInnerError` is `true`, the original error would be returned as `innerErr` property.
     */
    onInternalServerError(err, call) {
        call.logger.error(err);
        call.error('Internal Server Error', {
            code: 'INTERNAL_ERR',
            type: tsrpcProto.TsrpcErrorType.ServerError,
            innerErr: call.conn.server.options.returnInnerError ? err.message : undefined
        });
    }
    /**
     * Stop the server gracefully.
     * Wait all API requests finished and then stop the server.
     * @param maxWaitTime - The max time(ms) to wait before force stop the server.
     * `undefined` and `0` means unlimited time.
     */
    async gracefulStop(maxWaitTime) {
        if (this._status !== exports.ServerStatus.Opened) {
            throw new Error(`Cannot gracefulStop when server status is '${this._status}'.`);
        }
        this.logger.log('[GracefulStop] Start graceful stop, waiting all ApiCall finished...');
        this._status = exports.ServerStatus.Closing;
        let promiseWaitApi = new Promise(rs => {
            this._gracefulStop = {
                rs: rs
            };
        });
        return new Promise(rs => {
            let maxWaitTimer;
            if (maxWaitTime) {
                maxWaitTimer = setTimeout(() => {
                    maxWaitTimer = undefined;
                    if (this._gracefulStop) {
                        this._gracefulStop = undefined;
                        this.logger.log('Graceful stop timeout, stop the server directly.');
                        this.stop().then(() => { rs(); });
                    }
                }, maxWaitTime);
            }
            promiseWaitApi.then(() => {
                this.logger.log('All ApiCall finished, continue stop server.');
                if (maxWaitTimer) {
                    clearTimeout(maxWaitTimer);
                    maxWaitTimer = undefined;
                }
                if (this._gracefulStop) {
                    this._gracefulStop = undefined;
                    this.stop().then(() => { rs(); });
                }
            });
        });
    }
    /**
     * Execute API function through the inner connection, which is useful for unit test.
     *
     * **NOTICE**
     * The `req` and return value is native JavaScript object which is not compatible to JSON. (etc. ArrayBuffer, Date, ObjectId)
     * If you are using pure JSON as transfering, you may need use `callApiByJSON`.
     * @param apiName
     * @param req
     * @param options
     */
    callApi(apiName, req) {
        return new Promise(rs => {
            // 确认是哪个Service
            let service = this.serviceMap.apiName2Service[apiName];
            if (!service) {
                let errMsg = `Cannot find service: ${apiName}`;
                this.logger.warn(`[callApi]`, errMsg);
                rs({ isSucc: false, err: new tsrpcProto.TsrpcError(errMsg, { type: tsrpcProto.TsrpcErrorType.ServerError, code: 'ERR_API_NAME' }) });
                return;
            }
            let conn = new InnerConnection({
                dataType: 'json',
                server: this,
                id: '' + this._connIdCounter.getNext(),
                ip: '',
                return: {
                    type: 'raw',
                    rs: rs
                }
            });
            let call = new ApiCallInner({
                conn: conn,
                req: req,
                service: service
            });
            this._handleApiCall(call);
        });
    }
    /**
     * Like `server.callApi`, but both input and output are pure JSON object,
     * which can be `JSON.stringify()` and `JSON.parse()` directly.
     * Types that not compatible to JSON, would be encoded and decoded automatically.
     * @param apiName - The same with `server.callApi`, may be parsed from the URL.
     * @param jsonReq - Request data in pure JSON
     * @returns Encoded `ApiReturn<Res>` in pure JSON
     */
    /**
     * Process JSON request by inner proxy, this is useful when you are porting to cloud function services.
     * Both the input and output is pure JSON, ArrayBuffer/Date/ObjectId are encoded to string automatically.
     * @param apiName - Parsed from URL
     * @param req - Pure JSON
     * @returns - Pure JSON
     */
    async inputJSON(apiName, req) {
        if (apiName.startsWith('/')) {
            apiName = apiName.slice(1);
        }
        if (!this.serviceMap.apiName2Service[apiName]) {
            return {
                isSucc: false,
                err: new tsrpcProto.TsrpcError(`Invalid service name: ${apiName}`, {
                    type: tsrpcProto.TsrpcErrorType.ServerError,
                    code: 'INPUT_DATA_ERR'
                })
            };
        }
        return new Promise(rs => {
            let conn = new InnerConnection({
                dataType: 'json',
                server: this,
                id: '' + this._connIdCounter.getNext(),
                ip: '',
                return: {
                    type: 'json',
                    rs: rs
                }
            });
            this._onRecvData(conn, req, apiName);
        });
    }
    /**
     * Process input buffer by inner proxy, this is useful when you are porting to cloud function services.
     * @param buf Input buffer (may be sent by TSRPC client)
     * @returns Response buffer
     */
    inputBuffer(buf) {
        return new Promise(rs => {
            let conn = new InnerConnection({
                dataType: 'buffer',
                server: this,
                id: '' + this._connIdCounter.getNext(),
                ip: '',
                return: {
                    type: 'buffer',
                    rs: rs
                }
            });
            this._onRecvData(conn, buf);
        });
    }
    _parseServerInput(tsbuffer, serviceMap, data, serviceName) {
        var _a;
        if (data instanceof Uint8Array) {
            let opServerInputData = tsrpcBaseClient.TransportDataUtil.tsbuffer.decode(data, 'ServerInputData');
            if (!opServerInputData.isSucc) {
                return opServerInputData;
            }
            let serverInput = opServerInputData.value;
            // 确认是哪个Service
            let service = serviceMap.id2Service[serverInput.serviceId];
            if (!service) {
                return { isSucc: false, errMsg: `Cannot find service ID: ${serverInput.serviceId}` };
            }
            // 解码Body
            if (service.type === 'api') {
                let opReq = tsbuffer.decode(serverInput.buffer, service.reqSchemaId);
                return opReq.isSucc ? {
                    isSucc: true,
                    result: {
                        type: 'api',
                        service: service,
                        req: opReq.value,
                        sn: serverInput.sn
                    }
                } : opReq;
            }
            else {
                let opMsg = tsbuffer.decode(serverInput.buffer, service.msgSchemaId);
                return opMsg.isSucc ? {
                    isSucc: true,
                    result: {
                        type: 'msg',
                        service: service,
                        msg: opMsg.value
                    }
                } : opMsg;
            }
        }
        else {
            let json;
            if (typeof data === 'string') {
                try {
                    json = JSON.parse(data);
                }
                catch (e) {
                    return { isSucc: false, errMsg: `Input is not a valid JSON string: ${e.message}` };
                }
            }
            else {
                json = data;
            }
            let body;
            let sn;
            // Parse serviceName / body / sn
            let service;
            if (serviceName == undefined) {
                if (!Array.isArray(json)) {
                    return { isSucc: false, errMsg: `Invalid request format: unresolved service name.` };
                }
                serviceName = json[0];
                body = json[1];
                sn = json[2];
            }
            else {
                body = json;
            }
            // Get Service
            service = (_a = serviceMap.apiName2Service[serviceName]) !== null && _a !== void 0 ? _a : serviceMap.msgName2Service[serviceName];
            if (!service) {
                let errMsg = `Invalid service name: ${chalk__default["default"].cyan.underline(serviceName)}`;
                return { isSucc: false, errMsg: errMsg };
            }
            // Decode
            if (service.type === 'api') {
                let op = tsbuffer.decodeJSON(body, service.reqSchemaId);
                if (!op.isSucc) {
                    return op;
                }
                return {
                    isSucc: true,
                    result: {
                        type: 'api',
                        service: service,
                        sn: sn,
                        req: op.value
                    }
                };
            }
            else {
                let op = tsbuffer.decodeJSON(body, service.msgSchemaId);
                if (!op.isSucc) {
                    return op;
                }
                return {
                    isSucc: true,
                    result: {
                        type: 'msg',
                        service: service,
                        msg: op.value
                    }
                };
            }
        }
    }
}
BaseServer._isUncaughtExceptionProcessed = false;
const defaultBaseServerOptions = {
    json: false,
    strictNullChecks: false,
    apiTimeout: 30000,
    logger: new TerminalColorLogger,
    logLevel: 'debug',
    logReqBody: true,
    logResBody: true,
    logMsg: true,
    returnInnerError: process.env['NODE_ENV'] !== 'production'
};
exports.ServerStatus = void 0;
(function (ServerStatus) {
    ServerStatus["Opening"] = "OPENING";
    ServerStatus["Opened"] = "OPENED";
    ServerStatus["Closing"] = "CLOSING";
    ServerStatus["Closed"] = "CLOSED";
})(exports.ServerStatus || (exports.ServerStatus = {}));

/**
 * A call request by `client.sendMsg()`
 * @typeParam Msg - Type of the message
 * @typeParam ServiceType - The same `ServiceType` to server, it is used for code auto hint.
 */
class MsgCall extends BaseCall {
    constructor(options, logger) {
        super(options, logger !== null && logger !== void 0 ? logger : new PrefixLogger({
            logger: options.conn.logger,
            prefixs: [`[Msg:${options.service.name}]`]
        }));
        this.type = 'msg';
        this.msg = options.msg;
    }
}

class ApiCallHttp extends ApiCall {
    constructor(options) {
        super(options);
    }
    async _sendReturn(ret) {
        if (this.conn.dataType === 'text') {
            if (ret.isSucc) {
                this.conn.httpRes.statusCode = 200;
            }
            else {
                this.conn.httpRes.statusCode = ret.err.type === tsrpcProto.TsrpcErrorType.ApiError ? 200 : 500;
            }
        }
        return super._sendReturn(ret);
    }
}

class MsgCallHttp extends MsgCall {
    constructor(options) {
        super(options);
    }
}

class HttpConnection extends BaseConnection {
    constructor(options) {
        super(options, new PrefixLogger({
            logger: options.server.logger,
            prefixs: [`${options.ip} #${options.id}`]
        }));
        this.type = 'SHORT';
        this.ApiCallClass = ApiCallHttp;
        this.MsgCallClass = MsgCallHttp;
        this.httpReq = options.httpReq;
        this.httpRes = options.httpRes;
    }
    get status() {
        if (this.httpRes.writableFinished) {
            return exports.ConnectionStatus.Closed;
        }
        else if (this.httpRes.writableEnded) {
            return exports.ConnectionStatus.Closing;
        }
        else {
            return exports.ConnectionStatus.Opened;
        }
    }
    async doSendData(data, call) {
        if (typeof data === 'string') {
            this.httpRes.setHeader('Content-Type', 'application/json; charset=utf-8');
        }
        this.httpRes.end(typeof data === 'string' ? data : Buffer.from(data.buffer, data.byteOffset, data.byteLength));
        return { isSucc: true };
    }
    /**
     * Close the connection, the reason would be attached to response header `X-TSRPC-Close-Reason`.
     */
    close(reason) {
        if (this.status !== exports.ConnectionStatus.Opened) {
            return;
        }
        // 有Reason代表是异常关闭
        if (reason) {
            this.logger.warn(this.httpReq.method, this.httpReq.url, reason);
        }
        reason && this.httpRes.setHeader('X-TSRPC-Close-Reason', reason);
        this.httpRes.end();
    }
    // HTTP Server 一个conn只有一个call，对应关联之
    makeCall(input) {
        let call = super.makeCall(input);
        this.call = call;
        return call;
    }
}

class HttpUtil {
    static getClientIp(req) {
        var ipAddress;
        // The request may be forwarded from local web server.
        var forwardedIpsStr = req.headers['x-forwarded-for'];
        if (forwardedIpsStr) {
            // 'x-forwarded-for' header may return multiple IP addresses in
            // the format: "client IP, proxy 1 IP, proxy 2 IP" so take the
            // the first one
            var forwardedIps = forwardedIpsStr.split(',');
            ipAddress = forwardedIps[0];
        }
        if (!ipAddress) {
            // If request was not forwarded
            ipAddress = req.connection.remoteAddress;
        }
        // Remove prefix ::ffff:
        return ipAddress ? ipAddress.replace(/^::ffff:/, '') : '';
    }
    ;
}

/**
 * TSRPC Server, based on HTTP connection.
 * @typeParam ServiceType - `ServiceType` from generated `proto.ts`
 */
class HttpServer extends BaseServer {
    constructor(proto, options) {
        super(proto, {
            ...defaultHttpServerOptions,
            ...options
        });
        // 确保 jsonHostPath 以 / 开头和结尾
        this.options.jsonHostPath = this.options.jsonHostPath ?
            (this.options.jsonHostPath.startsWith('/') ? '' : '/') + this.options.jsonHostPath + (this.options.jsonHostPath.endsWith('/') ? '' : '/')
            : '/';
    }
    /**
     * {@inheritDoc BaseServer.start}
     */
    start() {
        if (this.httpServer) {
            throw new Error('Server already started');
        }
        return new Promise(rs => {
            this._status = exports.ServerStatus.Opening;
            this.logger.log(`Starting HTTP server ...`);
            this.httpServer = http__namespace.createServer((httpReq, httpRes) => {
                if (this.status !== exports.ServerStatus.Opened) {
                    httpRes.statusCode = 503;
                    httpRes.end();
                    return;
                }
                let ip = HttpUtil.getClientIp(httpReq);
                httpRes.statusCode = 200;
                httpRes.setHeader('X-Powered-By', `TSRPC ${TSRPC_VERSION}`);
                if (this.options.cors) {
                    httpRes.setHeader('Access-Control-Allow-Origin', this.options.cors);
                    httpRes.setHeader('Access-Control-Allow-Headers', 'Content-Type,*');
                    if (this.options.corsMaxAge) {
                        httpRes.setHeader('Access-Control-Max-Age', '' + this.options.corsMaxAge);
                    }
                    if (httpReq.method === 'OPTIONS') {
                        httpRes.writeHead(200);
                        httpRes.end();
                        return;
                    }
                }
                let chunks = [];
                httpReq.on('data', data => {
                    chunks.push(data);
                });
                let conn;
                httpReq.on('end', async () => {
                    var _a, _b;
                    let isJSON = this.options.jsonEnabled && ((_a = httpReq.headers["content-type"]) === null || _a === void 0 ? void 0 : _a.toLowerCase().includes('application/json'))
                        && httpReq.method === 'POST' && ((_b = httpReq.url) === null || _b === void 0 ? void 0 : _b.startsWith(this.options.jsonHostPath));
                    conn = new HttpConnection({
                        server: this,
                        id: '' + this._connIdCounter.getNext(),
                        ip: ip,
                        httpReq: httpReq,
                        httpRes: httpRes,
                        dataType: isJSON ? 'text' : 'buffer'
                    });
                    await this.flows.postConnectFlow.exec(conn, conn.logger);
                    let buf = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks);
                    if (conn.dataType === 'text') {
                        let url = conn.httpReq.url;
                        let urlEndPos = url.indexOf('?');
                        if (urlEndPos > -1) {
                            url = url.slice(0, urlEndPos);
                        }
                        let serviceName = url.slice(this.options.jsonHostPath.length);
                        this._onRecvData(conn, buf.toString(), serviceName);
                    }
                    else {
                        this._onRecvData(conn, buf);
                    }
                });
                // 处理连接异常关闭的情况
                httpRes.on('close', async () => {
                    var _a;
                    // 客户端Abort
                    if (httpReq.aborted) {
                        if (conn) {
                            if (conn.call) {
                                conn.call.logger.log('[ReqAborted]');
                            }
                            else {
                                conn.logger.log('[ReqAborted]');
                            }
                        }
                        else {
                            this.logger.log('[ReqAborted]', {
                                url: httpReq.url,
                                method: httpReq.method,
                                ip: ip,
                                chunksLength: chunks.length,
                                chunksSize: chunks.sum(v => v.byteLength),
                                reqComplete: httpReq.complete,
                                headers: httpReq.rawHeaders
                            });
                        }
                    }
                    // 非Abort，异常中断：直到连接关闭，Client也未end（Conn未生成）
                    else if (!conn) {
                        this.logger.warn('Socket closed before request end', {
                            url: httpReq.url,
                            method: httpReq.method,
                            ip: ip,
                            chunksLength: chunks.length,
                            chunksSize: chunks.sum(v => v.byteLength),
                            reqComplete: httpReq.complete,
                            headers: httpReq.rawHeaders
                        });
                    }
                    // 有Conn，但连接非正常end：直到连接关闭，也未调用过 httpRes.end 方法
                    else if (!httpRes.writableEnded) {
                        (((_a = conn.call) === null || _a === void 0 ? void 0 : _a.logger) || conn.logger).warn('Socket closed without response');
                    }
                    // Post Flow
                    if (conn) {
                        await this.flows.postDisconnectFlow.exec({ conn: conn }, conn.logger);
                    }
                });
            });
            if (this.options.socketTimeout) {
                this.httpServer.timeout = this.options.socketTimeout;
            }
            if (this.options.keepAliveTimeout) {
                this.httpServer.keepAliveTimeout = this.options.keepAliveTimeout;
            }
            this.httpServer.listen(this.options.port, () => {
                this._status = exports.ServerStatus.Opened;
                this.logger.log(`Server started at ${this.options.port}.`);
                rs();
            });
        });
    }
    /**
     * {@inheritDoc BaseServer.stop}
     */
    async stop() {
        if (!this.httpServer) {
            return;
        }
        this.logger.log('Stopping server...');
        return new Promise((rs) => {
            var _a;
            this._status = exports.ServerStatus.Closing;
            // 立即close，不再接受新请求
            // 等所有连接都断开后rs
            (_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.close(err => {
                this._status = exports.ServerStatus.Closed;
                this.httpServer = undefined;
                if (err) {
                    this.logger.error(err);
                }
                this.logger.log('Server stopped');
                rs();
            });
        });
    }
}
const defaultHttpServerOptions = {
    ...defaultBaseServerOptions,
    port: 3000,
    cors: '*',
    corsMaxAge: 3600,
    jsonHostPath: '/',
    // TODO: keep-alive time (to SLB)
};

class ApiCallWs extends ApiCall {
    constructor(options) {
        super(options);
    }
    async _prepareReturn(ret) {
        if (this.conn.status !== exports.ConnectionStatus.Opened) {
            this.logger.error('[SendReturnErr]', 'WebSocket is not opened', ret);
            this._return = ret;
            return;
        }
        return super._prepareReturn(ret);
    }
}

class MsgCallWs extends MsgCall {
    constructor(options) {
        super(options);
    }
}

/**
 * Connected client
 */
class WsConnection extends BaseConnection {
    constructor(options) {
        super(options, new PrefixLogger({
            logger: options.server.logger,
            prefixs: [`${options.ip} Conn#${options.id}`]
        }));
        this.type = "LONG";
        this.ApiCallClass = ApiCallWs;
        this.MsgCallClass = MsgCallWs;
        this._lastHeartbeatTime = 0;
        this.ws = options.ws;
        this.httpReq = options.httpReq;
        this.isDataTypeConfirmed = options.isDataTypeConfirmed;
        if (this.server.options.heartbeatWaitTime) {
            const timeout = this.server.options.heartbeatWaitTime;
            this._heartbeatInterval = setInterval(() => {
                if (Date.now() - this._lastHeartbeatTime > timeout) {
                    this.ws.close(3001, 'Receive heartbeat timeout');
                }
            }, timeout);
        }
        // Init WS
        this.ws.onclose = async (e) => {
            var _a;
            if (this._heartbeatInterval) {
                clearInterval(this._heartbeatInterval);
                this._heartbeatInterval = undefined;
            }
            await options.onClose(this, e.code, e.reason);
            (_a = this._rsClose) === null || _a === void 0 ? void 0 : _a.call(this);
        };
        this.ws.onerror = e => { this.logger.warn('[ClientErr]', e.error); };
        this.ws.onmessage = e => {
            let data;
            if (e.data instanceof ArrayBuffer) {
                data = Buffer.from(e.data);
            }
            else if (Array.isArray(e.data)) {
                data = Buffer.concat(e.data);
            }
            else if (Buffer.isBuffer(e.data)) {
                data = e.data;
            }
            else {
                data = e.data;
            }
            // 心跳包，直接回复
            if (data instanceof Buffer && data.equals(tsrpcBaseClient.TransportDataUtil.HeartbeatPacket)) {
                this.server.options.debugBuf && this.logger.log('[Heartbeat] Recv ping and send pong', tsrpcBaseClient.TransportDataUtil.HeartbeatPacket);
                this._lastHeartbeatTime = Date.now();
                this.ws.send(tsrpcBaseClient.TransportDataUtil.HeartbeatPacket);
                return;
            }
            // dataType 尚未确认，自动检测
            if (!this.isDataTypeConfirmed) {
                if (this.server.options.jsonEnabled && typeof data === 'string') {
                    this.dataType = 'text';
                }
                else {
                    this.dataType = 'buffer';
                }
                this.isDataTypeConfirmed = true;
            }
            // dataType 已确认
            this.server._onRecvData(this, data);
        };
    }
    get status() {
        if (this.ws.readyState === WebSocket__namespace.CLOSED) {
            return exports.ConnectionStatus.Closed;
        }
        if (this.ws.readyState === WebSocket__namespace.CLOSING) {
            return exports.ConnectionStatus.Closing;
        }
        return exports.ConnectionStatus.Opened;
    }
    async doSendData(data, call) {
        let opSend = await new Promise((rs) => {
            this.ws.send(data, e => {
                e ? rs({ isSucc: false, errMsg: e.message || 'Send buffer error' }) : rs({ isSucc: true });
            });
        });
        if (!opSend.isSucc) {
            return opSend;
        }
        return { isSucc: true };
    }
    /** Close WebSocket connection */
    close(reason) {
        // 已连接 Close之
        return new Promise(rs => {
            this._rsClose = rs;
            this.ws.close(1000, reason);
        }).finally(() => {
            this._rsClose = undefined;
        });
    }
}

/**
 * TSRPC Server, based on WebSocket connection.
 * It can support realtime cases.
 * @typeParam ServiceType - `ServiceType` from generated `proto.ts`
 */
class WsServer extends BaseServer {
    constructor(proto, options) {
        super(proto, {
            ...defaultWsServerOptions,
            ...options
        });
        this.connections = [];
        this._id2Conn = {};
        this._onClientConnect = (ws, httpReq) => {
            var _a;
            // 停止中 不再接受新的连接
            if (this._status !== exports.ServerStatus.Opened) {
                ws.close(1012);
                return;
            }
            // 推测 dataType 和 isDataTypeConfirmed
            let isDataTypeConfirmed = true;
            let dataType;
            let protocols = (_a = httpReq.headers['sec-websocket-protocol']) === null || _a === void 0 ? void 0 : _a.split(',').map(v => v.trim()).filter(v => !!v);
            if (protocols === null || protocols === void 0 ? void 0 : protocols.includes('text')) {
                dataType = 'text';
            }
            else if (protocols === null || protocols === void 0 ? void 0 : protocols.includes('buffer')) {
                dataType = 'buffer';
            }
            else {
                dataType = this.options.jsonEnabled ? 'text' : 'buffer';
                isDataTypeConfirmed = false;
            }
            // Create Active Connection
            let conn = new WsConnection({
                id: '' + this._connIdCounter.getNext(),
                ip: HttpUtil.getClientIp(httpReq),
                server: this,
                ws: ws,
                httpReq: httpReq,
                onClose: this._onClientClose,
                dataType: dataType,
                isDataTypeConfirmed: isDataTypeConfirmed
            });
            this.connections.push(conn);
            this._id2Conn[conn.id] = conn;
            conn.logger.log('[Connected]', `ActiveConn=${this.connections.length}`);
            this.flows.postConnectFlow.exec(conn, conn.logger);
        };
        this._onClientClose = async (conn, code, reason) => {
            this.connections.removeOne(v => v.id === conn.id);
            delete this._id2Conn[conn.id];
            conn.logger.log('[Disconnected]', `Code=${code} ${reason ? `Reason=${reason} ` : ''}ActiveConn=${this.connections.length}`);
            await this.flows.postDisconnectFlow.exec({ conn: conn, reason: reason }, conn.logger);
        };
    }
    /**
     * {@inheritDoc BaseServer.start}
     */
    start() {
        if (this._wsServer) {
            throw new Error('Server already started');
        }
        this._status = exports.ServerStatus.Opening;
        return new Promise((rs, rj) => {
            this.logger.log('Starting WebSocket server...');
            this._wsServer = new WebSocket.Server({
                port: this.options.port
            }, () => {
                this.logger.log(`Server started at ${this.options.port}...`);
                this._status = exports.ServerStatus.Opened;
                rs();
            });
            this._wsServer.on('connection', this._onClientConnect);
            this._wsServer.on('error', e => {
                this.logger.error('[ServerError]', e);
                rj(e);
            });
        });
    }
    /**
     * {@inheritDoc BaseServer.stop}
     */
    async stop() {
        // Closed Already
        if (!this._wsServer) {
            throw new Error('Server has not been started');
        }
        if (this._status === exports.ServerStatus.Closed) {
            throw new Error('Server is closed already');
        }
        this._status = exports.ServerStatus.Closing;
        return new Promise(async (rs, rj) => {
            await Promise.all(this.connections.map(v => v.close('Server Stop')));
            this._wsServer.close(err => { err ? rj(err) : rs(); });
        }).then(() => {
            this.logger.log('Server stopped');
            this._status = exports.ServerStatus.Closed;
            this._wsServer = undefined;
        });
    }
    /**
     * Send the same message to many connections.
     * No matter how many target connections are, the message would be only encoded once.
     * @param msgName
     * @param msg - Message body
     * @param connIds - `id` of target connections, `undefined` means broadcast to every connections.
     * @returns Send result, `isSucc: true` means the message buffer is sent to kernel, not represents the clients received.
     */
    async broadcastMsg(msgName, msg, conns) {
        let connStr;
        if (!conns) {
            conns = this.connections;
            connStr = '*';
        }
        else {
            connStr = conns ? conns.map(v => v.id).join(',') : '*';
        }
        if (!conns.length) {
            return { isSucc: true };
        }
        if (this.status !== exports.ServerStatus.Opened) {
            this.logger.warn('[BroadcastMsgErr]', `[${msgName}]`, `[To:${connStr}]`, 'Server not open');
            return { isSucc: false, errMsg: 'Server not open' };
        }
        // GetService
        let service = this.serviceMap.msgName2Service[msgName];
        if (!service) {
            this.logger.warn('[BroadcastMsgErr]', `[${msgName}]`, `[To:${connStr}]`, 'Invalid msg name: ' + msgName);
            return { isSucc: false, errMsg: 'Invalid msg name: ' + msgName };
        }
        // Encode group by dataType
        let _opEncodeBuf;
        let _opEncodeText;
        const getOpEncodeBuf = () => {
            if (!_opEncodeBuf) {
                _opEncodeBuf = tsrpcBaseClient.TransportDataUtil.encodeServerMsg(this.tsbuffer, service, msg, 'buffer', 'LONG');
            }
            return _opEncodeBuf;
        };
        const getOpEncodeText = () => {
            if (!_opEncodeText) {
                _opEncodeText = tsrpcBaseClient.TransportDataUtil.encodeServerMsg(this.tsbuffer, service, msg, 'text', 'LONG');
            }
            return _opEncodeText;
        };
        // 测试一下编码可以通过
        let op = conns.some(v => v.dataType === 'buffer') ? getOpEncodeBuf() : getOpEncodeText();
        if (!op.isSucc) {
            this.logger.warn('[BroadcastMsgErr]', `[${msgName}]`, `[To:${connStr}]`, op.errMsg);
            return op;
        }
        this.options.logMsg && this.logger.log(`[BroadcastMsg]`, `[${msgName}]`, `[To:${connStr}]`, msg);
        // Batch send
        let errMsgs = [];
        return Promise.all(conns.map(async (conn) => {
            // Pre Flow
            let pre = await this.flows.preSendMsgFlow.exec({ conn: conn, service: service, msg: msg }, this.logger);
            if (!pre) {
                conn.logger.debug('[preSendMsgFlow]', 'Canceled');
                return { isSucc: false, errMsg: 'Prevented by preSendMsgFlow' };
            }
            msg = pre.msg;
            // Do send!
            let opSend = await conn.sendData((conn.dataType === 'buffer' ? getOpEncodeBuf() : getOpEncodeText()).output);
            if (!opSend.isSucc) {
                return opSend;
            }
            // Post Flow
            this.flows.postSendMsgFlow.exec(pre, this.logger);
            return { isSucc: true };
        })).then(results => {
            for (let i = 0; i < results.length; ++i) {
                let op = results[i];
                if (!op.isSucc) {
                    errMsgs.push(`Conn#conns[i].id: ${op.errMsg}`);
                }
            }
            if (errMsgs.length) {
                return { isSucc: false, errMsg: errMsgs.join('\n') };
            }
            else {
                return { isSucc: true };
            }
        });
    }
    ;
}
const defaultWsServerOptions = {
    ...defaultBaseServerOptions,
    port: 3000
};

exports.ApiCall = ApiCall;
exports.ApiCallHttp = ApiCallHttp;
exports.ApiCallWs = ApiCallWs;
exports.BaseCall = BaseCall;
exports.BaseConnection = BaseConnection;
exports.BaseServer = BaseServer;
exports.HttpClient = HttpClient;
exports.HttpConnection = HttpConnection;
exports.HttpServer = HttpServer;
exports.MsgCall = MsgCall;
exports.MsgCallHttp = MsgCallHttp;
exports.MsgCallWs = MsgCallWs;
exports.PrefixLogger = PrefixLogger;
exports.TSRPC_VERSION = TSRPC_VERSION;
exports.TerminalColorLogger = TerminalColorLogger;
exports.WsClient = WsClient;
exports.WsConnection = WsConnection;
exports.WsServer = WsServer;
exports.defaultBaseServerOptions = defaultBaseServerOptions;
exports.defaultHttpServerOptions = defaultHttpServerOptions;
Object.keys(tsrpcBaseClient).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return tsrpcBaseClient[k]; }
    });
});
Object.keys(tsrpcProto).forEach(function (k) {
    if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return tsrpcProto[k]; }
    });
});
