#!/usr/bin/env node
/*!
 * TSRPC Command-line Interface v2.4.3
 * -----------------------------------------
 * MIT LICENSE
 * KingWorks (C) Copyright 2022
 * https://github.com/k8w/tsrpc-cli
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var chalk = require('chalk');
require('k8w-extend-native');
var minimist = require('minimist');
var path = require('path');
var console$1 = require('console');
var fs$1 = require('fs-extra');
var glob = require('glob');
var tsbufferProtoGenerator = require('tsbuffer-proto-generator');
var fs = require('fs');
require('ts-node/register');
var childProcess = require('child_process');
var ora = require('ora');
var inquirer = require('inquirer');
var tsbuffer = require('tsbuffer');
var chokidar = require('chokidar');
var tsbufferSchema = require('tsbuffer-schema');
var tsbufferValidator = require('tsbuffer-validator');
var typescriptFormatter = require('typescript-formatter');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var minimist__default = /*#__PURE__*/_interopDefaultLegacy(minimist);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default$1 = /*#__PURE__*/_interopDefaultLegacy(fs$1);
var glob__default = /*#__PURE__*/_interopDefaultLegacy(glob);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var childProcess__default = /*#__PURE__*/_interopDefaultLegacy(childProcess);
var ora__default = /*#__PURE__*/_interopDefaultLegacy(ora);
var inquirer__default = /*#__PURE__*/_interopDefaultLegacy(inquirer);
var chokidar__default = /*#__PURE__*/_interopDefaultLegacy(chokidar);

/**
 * 用于 `tsrpc.config.ts` 的代码模板
 * @public
 */
class CodeTemplate {
    /**
     * 自公共基类继承的 Ptl
     */
    static getExtendedPtl(baseFile = 'src/shared/protocols/base.ts', baseReq = 'BaseRequest', baseRes = 'BaseResponse', baseConf = 'BaseConf') {
        return (ptlBaseName, ptlPath, ptlDir) => {
            const importPath = path__default["default"].relative(path__default["default"].dirname(ptlPath), path__default["default"].resolve(baseFile.replace(/\.ts$/, ''))).replace(/\\/g, '/');
            return `import { ${baseReq}, ${baseRes}, ${baseConf} } from "${importPath.startsWith('.') ? importPath : `./${importPath}`}";

export interface Req${ptlBaseName} extends ${baseReq} {
    
}

export interface Res${ptlBaseName} extends ${baseRes} {
    
}

export const conf: ${baseConf} = {
    
}`;
        };
    }
    /**
     * 自公共基类继承的 Msg
     */
    static getExtendedMsg(baseFile = 'src/shared/protocols/base.ts', baseMsg = 'BaseMessage', baseConf = 'BaseConf') {
        return (msgBaseName, msgPath, msgDir) => `import { ${baseMsg}, ${baseConf} } from "./${path__default["default"].relative(path__default["default"].dirname(msgPath), path__default["default"].resolve(baseFile.replace(/\.ts$/, ''))).replace(/\\/g, '/')}";

export interface Msg${msgBaseName} extends ${baseMsg} {
    
}

export const conf: ${baseConf} = {
    
}`;
    }
}
/**
 * 默认 Ptl
 */
CodeTemplate.defaultPtl = ptlBaseName => `export interface Req${ptlBaseName} {
    
}

export interface Res${ptlBaseName} {
    
}
`;
/**
 * 默认 Msg
 */
CodeTemplate.defaultMsg = msgBaseName => `export interface Msg${msgBaseName} {
    
}
`;
/**
 * 默认 Api
 */
CodeTemplate.defaultApi = (apiBaseName, apiFileDir, ptlFileDir) => `import { ApiCall } from "tsrpc";
import { Req${apiBaseName}, Res${apiBaseName} } from "${path__default["default"].relative(apiFileDir, ptlFileDir).replace(/\\/g, '/')}/Ptl${apiBaseName}";

export async function Api${apiBaseName}(call: ApiCall<Req${apiBaseName}, Res${apiBaseName}>) {
    // TODO
    call.error('API Not Implemented');
}`;

const i18nEnUs = {
    welcome: 'https://npmjs.com/tsrpc\nWelcome to TSRPC utilities V${version}',
    help: `
Usage：

    --- [Recommended] Use Via Config File ---

    tsrpc-cli proto --config tsrpc.config.ts
    tsrpc-cli api   --config tsrpc.config.ts
    tsrpc-cli sync  --config tsrpc.config.ts
    tsrpc-cli link  --config tsrpc.config.ts
    tsrpc-cli dev   --config tsrpc.config.ts
    tsrpc-cli build --config tsrpc.config.ts
    tsrpc-cli doc --config tsrpc.config.ts

    ---------- Use Via CLI Params  ----------

    tsrpc-cli init                           Init "tsrpc.config.ts" and scripts in package.json

    tsrpc-cli proto <options>                Generate proto file
        -i, --input <file>                      Input TS file (support glob expression)
                                                It would generate all exported types
        -o, --output <file>                     Output file (or print to CLI)
        -c, --compatible <file>                 Compatible mode, compatible to old proto (=output by default)
        --new                                   Generate fresh new proto (no compatible)
        --ugly                                  Output as ugly JSON (no indent and smaller)
        --verbose                               Show debug info
        --ignore <glob>                         Files to be ignored from --input

    tsrpc-cli api <options>                  Generate TSRPC API implementations
        -i, --input <file>                      Proto file path (proto.ts or proto.json)
        -o, --output <folder>                   Output api folder path
    
    tsrpc-cli sync                           Sync directory
        --from <dir>                            Source path
        --to <dir>                              Target path (copy and set as read-only)

    tsrpc-cli link <options>                 Create symlink (cross all operating system)
        --from <dir>                            Source path
        --to <dir>                              Target path for created symlink

    tsrpc-cli dev <options>                  Run local dev server
        --config <file>                         Path of config file
        --entry <file>                          Entry file，default is "src/index.ts"

    tsrpc-cli build <options>                Build the server project
        --config <file>                         Path of config file

    tsrpc-cli doc <options>                  Generate API documents (Swagger/OpenAPI, Markdown, TSAPI)
        -i, --input <folder>                    The path of protocols folder
        -o, --output <folder>                   The path of output documents folder
        --verbose                               Show debug info
        --ignore <glob>                         Files to be ignored from --input

Buffer Utilities:

    tsrpc-cli encode <options> [exp]         Encode a JS expression or a file (content is JS expression)
        [exp]                                   Expression to encode (e.g. "123" "new Uint8Array([1,2,3])")
        -p, --proto <file>                      Proto file to use
        -s, --schema <id>                       SchemaID (filePath/TypeName)
        -i, --input <file>                      Input file path, alternative to [exp]
        -o, --output <file>                     Output file path (or print to CLI)
        --verbose                               Show debug info
                                            
    tsrpc-cli decode <options> [binstr]      Decode buffer
        [binstr]                                Buffer to decode, hex string, like "0F A2 E3"
        -p, --proto <file>                      Proto file
        -s, --schema <id>                       SchemaID (filePath/TypeName)
        -i, --input <file>                      Input file path, alternative to [binstr]
        -o, --output <file>                     Output file path (or print to CLI)
        --verbose                               Show debug info

    tsrpc-cli validate <options> [exp]       Validate if a JS expression is valid to a schema
        [exp]                                   Expression to validate (e.g. "123" "new Uint8Array([1,2,3])")
        -p, --proto <file>                      Proto file to use
        -s, --schema <id>                       SchemaID (filePath/TypeName)
        -i, --input <file>                      Input file path, alternative to [exp]

    tsrpc-cli show <file>                    Show a binary file as hex string
`.trim(),
    example: `
Example：

    tsrpc-cli dev --entry src/xxx.ts         Run local dev server
    tsrpc-cli build                          Build the server project
    tsrpc-cli doc                            Generate API document
`.trim(),
    errCmd: 'Error command, use "tsrpc-cli -h" to see more help info.',
    missingParam: 'Missing parameter ${param}, use "tsrpc-cli -h" to see more help info.',
    shouldBeDir: '${path} should be a directory',
    protoSucc: '✔ ServiceProto generated to: ${output}',
    protoFailed: (output) => `⨯ Generate ServiceProto failed, please check if there is any TypeScript compile error : ${output}`,
    fileNotExists: 'File not exists: ${file}',
    fileOpenError: 'Failed to open file: ${file}',
    jsParsedError: 'Failed to parse JS expression from: ${file}',
    invalidProtoExt: '旧 ServiceProto 格式非法，仅支持 .ts 和 .json 文件: ${file}',
    protoParsedError: 'Failed to parse old proto: ${file}',
    expParsedError: 'Invalid JS expression',
    or: 'or',
    and: 'and',
    encodeSucc: '✔ Encoded succ to: ${output}',
    decodeSucc: '✔ Decoded succ to: ${output}',
    apiSucc: '✔ Api${apiName} generated: ${apiPath}',
    allApiSucc: '✔ Success，${newCount} new API generated',
    validateSucc: '✔ Validate succ',
    validateFail: '⨯ Validate fail: ${msg}',
    error: ' ERROR ',
    success: ' SUCCESS ',
    helpGuide: 'Use "tsrpc-cli -h" to see more help info.',
    compatibleError: 'Failed to keep compatible with old proto: \n\t|- ${innerError}',
    canOptimizeByNew: (oldProtoPath) => `Redundancy in ServiceProto is detected, delete '${oldProtoPath}' manually to optimize this, but it would cause incompatibility between the latest and older protocol. `,
    dirNotExists: 'Directory not exists: ${dir}',
    codeError: 'Build TypeScript failed, please fix code error',
    ifUpdateProto: 'A protocol change is detected, do you need to regenerate ServiceProto?',
    ifSyncNow: 'Execute "npm run sync" after generated successfully?',
    syncFailed: 'Execute "npm run sync" failed, you can manually finish syncing.',
    deleteConfirm: '${target}\nis existed already，delete it and continue?',
    canceled: 'CANCELED',
    confInvalid: 'Invalid TSRPC config file: ${path}',
    missingConfigItem: (itemName) => `Missing '${itemName}' in config file`,
    nothingSyncConf: `'sync' is not configurated in the config file`,
    syncedSucc: '✔ Synced successfully',
    allSyncedSucc: '✔ All Synced successfully',
    copy: 'Copy Files:',
    link: 'Create Symlink:',
    junction: 'Create Junction:',
    linkedSucc: '✔ Linked successfully',
    allLinkedSucc: '✔ All linked successfully',
    elevatingForLink: 'Asking for authorization to create symlink',
    linkFailed: 'Authorization to create Symlink failed. Please select "Yes" in the authorization dialog: ',
    linkRetry: 'Retry',
    linkJunction: 'Create Junction instead (Not recommended)',
    devServerRestarting: '\n------ Recompiling & Restarting ------\n',
    startDevServer: '✔ Start Dev Server:',
    devServerStopped: '⨯ Dev Server Stopped',
    protoNotReady: '⨯ Dev Server cannot start，please fix ServiceProto firstly',
    buildClean: (outDir) => `Clean '${outDir}'`,
    buildTsc: `Compile TypeScript`,
    buildCopyFiles: `Copy Files`,
    buildSucc: 'Build Successfully!',
    docOpenApiSucc: (path) => `OpenAPI generated successfully: ${chalk__default["default"].cyan(path)}`,
    docTsapiSucc: (path) => `TSAPI generated successfully: ${chalk__default["default"].cyan(path)}`,
    docMdSucc: (path) => `Markdown generated successfully: ${chalk__default["default"].cyan(path)}`,
    fileAlreadyExists: (path) => `${path} already exists`,
    npmNotInited: `package.json not exists，please run ${chalk__default["default"].cyan('npm init')} first`,
    initSucc: (path) => `✔ Init successfully: ${path}`,
};

const i18nZhCn = {
    welcome: 'https://npmjs.com/tsrpc\n欢迎进入 TSRPC 实用工具 V${version}',
    help: `
使用说明：

    ---- [推荐] 通过配置文件使用 ----

    tsrpc-cli proto --config tsrpc.config.ts
    tsrpc-cli api   --config tsrpc.config.ts
    tsrpc-cli sync  --config tsrpc.config.ts
    tsrpc-cli link  --config tsrpc.config.ts
    tsrpc-cli dev   --config tsrpc.config.ts
    tsrpc-cli build --config tsrpc.config.ts
    tsrpc-cli doc --config tsrpc.config.ts

    ------- 通过命令行参数使用 -------

    tsrpc-cli init                           初始化 tsrpc.config.ts 文件和 package.json scripts

    tsrpc-cli proto <options>                生成TSRPC Proto文件
        -i, --input <folder>                    用来生成Proto的协议文件夹路径
        -o, --output <file>                     输出的文件路径，不指定将直接输出到命令行
                                                -o XXX.ts 和 -o XXX.json 将对应输出两种不同的格式
        -c, --compatible <file>                 兼容模式：要兼容的旧Proto文件的路径（默认同output）
        --new                                   不兼容旧版，生成全新的Proto文件
        --ugly                                  输出为可读性较差但体积更小压缩格式
        --verbose                               显示调试信息
        --ignore <glob>                         从--input范围中要忽略的文件，Glob 表达式
                                                支持传入多个，例如 --ignore "AAA" --ignore "BBB"

    tsrpc-cli api <options>                  自动生成TSRPC API实现
        -i, --input <file>                      Proto文件的路径
        -o, --output <folder>                   输出的API文件夹路径

    tsrpc-cli sync <options>                 同步文件夹内容，初始化 Symlink 或只读复制文件
        --from <dir>                            要同步的源文件夹
        --to <dir>                              要同步到的目标位置（只读复制）

    tsrpc-cli link <options>                 在目标位置创建到源的 Symlink，以实现自动同步
        --from <dir>                            要同步的源文件夹
        --to <dir>                              创建 Symlink 的目标位置

    tsrpc-cli dev <options>                  启动本地开发服务器，当源代码变更时自动重启
        --config <file>                         配置文件路径
        --entry <file>                          程序入口点，默认 "src/index.ts"

    tsrpc-cli build <options>                构建 TSRPC 后端项目
        --config <file>                         配置文件路径

    tsrpc-cli doc <options>                  生成多种格式的 API 接口文档 （如 Swagger/OpenAPI、Markdown、TSAPI）
        -i, --input <folder>                    协议文件夹路径
        -o, --output <folder>                   输出文档的文件夹路径
        --verbose                               显示调试信息
        --ignore <glob>                         从--input范围中要忽略的文件，Glob 表达式
                                                支持传入多个，例如 --ignore "AAA" --ignore "BBB"

    
二进制调试工具：

    tsrpc-cli encode <options> [exp]         编码JS表达式
        [exp]                                   要编码的值（JS表达式，例如"123" "new Uint8Array([1,2,3])"）
        -p, --proto <file>                      编码要使用的Proto文件
        -s, --schema <id>                       编码要使用的SchemaID
        -i, --input <file>                      输入为文件，不可与[exp]同用（文件内容为JS表达式）
        -o, --output <file>                     输出的文件路径，不指定将直接输出到命令行
        --verbose                               显示调试信息
                                            
    tsrpc-cli decode <options> [binstr]      解码二进制数据
        [binstr]                                要解码的二进制数据的字符串表示，如"0F A2 E3 F2 D9"
        -p, --proto <file>                      解码要使用的Proto文件
        -s, --schema <id>                       解码要使用的SchemaID
        -i, --input <file>                      输入为文件，不可与[binstr]同用
        -o, --output <file>                     输出的文件路径，不指定将直接输出到命令行
        --verbose                               显示调试信息

    tsrpc-cli validate <options> [exp]       验证JSON数据
        [exp]                                   要验证的值（JS表达式，例如"123" "new Uint8Array([1,2,3])"）
        -p, --proto <file>                      验证要使用的Proto文件
        -s, --schema <id>                       验证要使用的SchemaID
        -i, --input <file>                      输入为文件，不可与[exp]同用（文件内容为JS表达式）

    tsrpc-cli show <file>                    打印二进制文件内容
`.trim(),
    example: `
使用示例：

    tsrpc-cli dev --entry src/xxx.ts         启动本地开发服务器
    tsrpc-cli build                          构建后端项目
    tsrpc-cli doc                            生成 API 接口文档
`.trim(),
    errCmd: '命令格式有误，键入 tsrpc-cli -h 以查看帮助。',
    missingParam: '缺少 ${param} 参数，键入 tsrpc-cli -h 以查看更多信息。',
    shouldBeDir: '${path} 应当为一个文件夹',
    protoSucc: '✔ ServiceProto 已生成到：${output}',
    protoFailed: (output) => `⨯ ServiceProto 生成失败，请检查 TypeScript 代码是否编译报错: ${output}`,
    fileNotExists: '文件不存在：${file}',
    fileOpenError: '文件打开失败: ${file}',
    jsParsedError: 'JS表达式解析失败: ${file}',
    invalidProtoExt: '旧 ServiceProto 格式非法，仅支持 .ts 和 .json 文件: ${file}',
    protoParsedError: '旧 ServiceProto 文件解析失败: ${file}',
    expParsedError: '表达式解析失败',
    or: '或',
    and: '和',
    encodeSucc: '✔ 编码结果已生成到：${output}',
    decodeSucc: '✔ 解码结果已生成到：${output}',
    apiSucc: '✔ Api${apiName} 生成成功: ${apiPath}',
    allApiSucc: '✔ 完成，共生成 ${newCount} 个新的 API 文件。',
    validateSucc: '✔ 验证通过',
    validateFail: '⨯ 验证不通过: ${msg}',
    error: ' 错误 ',
    success: ' 成功 ',
    helpGuide: '键入 tsrpc-cli -h 查看更多帮助信息',
    compatibleError: '兼容旧Proto失败: ${innerError}',
    canOptimizeByNew: (oldProtoPath) => `检测到协议中可优化的冗余信息，删除 '${oldProtoPath}' 即可优化，但将导致新旧协议的不兼容。`,
    dirNotExists: '文件夹不存在: ${dir}',
    codeError: 'TypeScript 构建失败，请检查代码报错',
    ifUpdateProto: '检测到协议变更，是否重新生成 ServiceProto？',
    ifSyncNow: '生成后执行同步（npm run sync）吗？',
    syncFailed: '执行 "npm run sync" 失败, 你可以手动完成同步。',
    deleteConfirm: '${target}\n目标已经存在，是否删除再继续？',
    canceled: '已取消',
    confInvalid: '配置文件解析失败: ${path}',
    missingConfigItem: (itemName) => `配置文件中缺少配置项 '${itemName}'`,
    nothingSyncConf: '配置文件中没有配置 sync 项目',
    syncedSucc: '✔ 同步完成',
    allSyncedSucc: '✔ 已完成所有同步',
    copy: '复制文件:',
    link: '创建 Symlink:',
    junction: '创建 Junction:',
    linkedSucc: '✔ Symlink 创建成功',
    allLinkedSucc: '✔ 已完成所有 Symlink 创建',
    elevatingForLink: '正在获取创建 Symlink 所需的授权',
    linkFailed: '创建 Symlink 授权失败，请在授权弹框选择 “是” 以继续：',
    linkRetry: '重 试',
    linkJunction: '改为创建 Junction（不推荐）',
    devServerRestarting: '\n———— Dev Server 自动重启中 ————\n',
    startDevServer: '✔ 启动本地服务:',
    devServerStopped: '⨯ Dev Server 已停止运行',
    protoNotReady: '⨯ Dev Server 未启动，请先修复 ServiceProto 问题',
    buildClean: (outDir) => `清空目录 '${outDir}'`,
    buildTsc: `编译 TypeScript`,
    buildCopyFiles: `复制文件`,
    buildSucc: '构建成功！',
    docOpenApiSucc: (path) => `OpenAPI 已成成到：${chalk__default["default"].cyan(path)}`,
    docTsapiSucc: (path) => `TSAPI 已成成到：${chalk__default["default"].cyan(path)}`,
    docMdSucc: (path) => `Markdown 已成成到：${chalk__default["default"].cyan(path)}`,
    fileAlreadyExists: (path) => `${path} 已经存在`,
    npmNotInited: `package.json 不存在，请先执行 ${chalk__default["default"].cyan('npm init')} 初始化`,
    initSucc: (path) => `✔ 初始化成功：${path}`,
};

// 根据系统语言判断中英文
const i18n = require('os-locale').sync() === 'zh-CN' ? i18nZhCn : i18nEnUs;
// export const i18n = zhCN;

function showLogo() {
    console.log(chalk__default["default"].green(`                                                   
88888888888 .d8888b.  8888888b.  8888888b.   .d8888b.  
    888    d88P  Y88b 888   Y88b 888   Y88b d88P  Y88b 
    888    Y88b.      888    888 888    888 888    888 
    888     "Y888b.   888   d88P 888   d88P 888        
    888        "Y88b. 8888888P"  8888888P"  888        
    888          "888 888 T88b   888        888    888 
    888    Y88b  d88P 888  T88b  888        Y88b  d88P 
    888     "Y8888P"  888   T88b 888         "Y8888P"  
------------------------------------------------------------------------
`));
}
function formatStr(str, data) {
    for (let key in data) {
        str = str.replace(`\${${key}}`, data[key]);
    }
    return str;
}
function error(str, data) {
    if (data) {
        str = formatStr(str, data);
    }
    return new Error(str);
}
function colorJson(json) {
    return JSON.colorStringify(json, null, 2);
}
function hex2Bin(hexStr) {
    return Buffer.from(new Uint8Array(hexStr.trim().split(/\s+/).map(v => parseInt('0x' + v))));
}
function buf2Hex(buf) {
    let arr = [];
    buf.forEach(v => {
        let char = v.toString(16).toUpperCase();
        if (char.length === 1) {
            char = '0' + char;
        }
        arr.push(char);
    });
    return arr.join(' ');
}

/**
 * 引入 TS 模块，但不缓存
 */
function importTS(modulePath) {
    modulePath = path__default["default"].resolve(modulePath);
    if (!fs__default["default"].existsSync(modulePath)) {
        throw error(i18n.fileNotExists, { file: modulePath });
    }
    let module = require(modulePath);
    delete require.cache[modulePath];
    return module;
}
function importTsrpcConfig(modulePath) {
    var _a, _b;
    let module = importTS(modulePath);
    let conf = (_b = (_a = module['default']) !== null && _a !== void 0 ? _a : module['conf']) !== null && _b !== void 0 ? _b : module['config'];
    if (!conf) {
        throw error(i18n.confInvalid, { path: path__default["default"].resolve(modulePath) });
    }
    return conf;
}

class ProtoUtil {
    static async loadServiceProto(filepath, logger, useRegExpWhenTsError = true) {
        if (await fs__default$1["default"].access(filepath).catch(e => true)) {
            logger === null || logger === void 0 ? void 0 : logger.error(formatStr(i18n.fileNotExists, { file: path__default["default"].resolve(filepath) }));
            return undefined;
        }
        if (filepath.endsWith('.ts')) {
            // 首先尝试通过 ts-node 直接解析
            let module;
            try {
                module = importTS(path__default["default"].resolve(filepath));
            }
            catch (e) { }
            if (module === null || module === void 0 ? void 0 : module.serviceProto) {
                return module.serviceProto;
            }
            // ts-node 解析失败：由于上面检测过，文件必定存在，所以此时应该是 serviceProto.ts 编译报错
            // 尝试通过字符串匹配方式解析 ServiceProto
            if (useRegExpWhenTsError) {
                // Read file
                let fileContent = await fs__default$1["default"].readFile(filepath, 'utf-8').catch();
                if (fileContent) {
                    // Match ServiceProto by RegExp
                    let match = fileContent.match(/export const serviceProto: ServiceProto<ServiceType> = (\{[\s\S]+\});/);
                    if (match) {
                        try {
                            let proto = JSON.parse(match[1]);
                            return proto;
                        }
                        catch { }
                    }
                }
            }
            // 解析失败
            logger === null || logger === void 0 ? void 0 : logger.error(formatStr(i18n.protoParsedError, { file: path__default["default"].resolve(filepath) }));
            return undefined;
        }
        else if (filepath.endsWith('.json')) {
            // 打开OldFile
            let fileContent = (await fs__default$1["default"].readFile(filepath)).toString();
            try {
                return JSON.parse(fileContent);
            }
            catch (e) {
                logger === null || logger === void 0 ? void 0 : logger.error(formatStr(i18n.protoParsedError, { file: path__default["default"].resolve(filepath) }));
                return undefined;
            }
        }
        else {
            logger === null || logger === void 0 ? void 0 : logger.warn(formatStr(i18n.invalidProtoExt, { file: path__default["default"].resolve(filepath) }));
            return undefined;
        }
    }
    static async parseProtoAndSchema(proto, schemaId) {
        // #region 解析Proto
        if (!proto) {
            throw error(i18n.missingParam, { param: '--proto' });
        }
        if (!schemaId) {
            throw error(i18n.missingParam, { param: '--schema' });
        }
        let serviceProto;
        try {
            serviceProto = await ProtoUtil.loadServiceProto(proto);
        }
        catch (e) {
            throw error(e.message);
        }
        if (!serviceProto) {
            throw error(i18n.fileOpenError, { file: path__default["default"].resolve(proto) });
        }
        return { proto: serviceProto.types, schemaId: schemaId };
        // #endregion
    }
    /**
     * 生成 ServiceProto
     * @param options
     * @returns
     */
    static async generateServiceProto(options) {
        var _a, _b;
        const oldProto = (_a = options.oldProto) === null || _a === void 0 ? void 0 : _a.proto;
        let errMsgs = [];
        // 标准化路径（抹平系统差异）
        const protocolDir = options.protocolDir.replace(/\\/g, '/').replace(/\/+$/, '');
        // 只能填写文件夹 不支持通配符
        if (!(await fs__default$1["default"].stat(options.protocolDir)).isDirectory()) {
            throw error(i18n.shouldBeDir, { path: protocolDir });
        }
        // 查找所有目标 Ptl 和 Msg 文件，输出标准化的相对路径
        let fileList = glob__default["default"].sync(protocolDir + '/**/{Ptl,Msg}?*.ts', {
            ignore: options.ignore,
        }).map(v => path__default["default"].relative(protocolDir, v).replace(/\\/g, '/'));
        // 临时切换working dir
        // let originalCwd = process.cwd();
        // process.chdir(protocolDir);
        // 生成 types （TSBufferSchema）
        const EXP_DIR_TYPE_NAME = /^(.+\/)?(Ptl|Msg)([^\.\/\\]+)\.ts$/;
        try {
            var typeProto = await new tsbufferProtoGenerator.TSBufferProtoGenerator({
                verbose: options.verbose,
                baseDir: protocolDir,
                customSchemaIds: ['mongodb/ObjectId', 'mongodb/ObjectID', 'bson/ObjectId', 'bson/ObjectID'],
                keepComment: options.keepComment
            }).generate(fileList, {
                compatibleResult: oldProto === null || oldProto === void 0 ? void 0 : oldProto.types,
                filter: info => {
                    let infoPath = info.path.replace(/\\/g, '/');
                    let match = infoPath.match(EXP_DIR_TYPE_NAME);
                    if (!match) {
                        return false;
                    }
                    if (match[2] === 'Ptl') {
                        return info.name === 'Req' + match[3] || info.name === 'Res' + match[3];
                    }
                    else {
                        return info.name === 'Msg' + match[3];
                    }
                },
                logger: options.verbose ? console : undefined
            });
        }
        catch (e) {
            e.message = (e.message.startsWith('⨯') ? '' : '⨯ ') + e.message;
            throw e;
        }
        // 生成 services
        let services = [];
        for (let filepath of fileList) {
            let match = filepath.match(EXP_DIR_TYPE_NAME);
            let typePath = filepath.replace(/^\.\//, '').replace(/\.ts$/, '');
            // 解析conf
            let tsModule = importTS(path__default["default"].resolve(protocolDir, filepath));
            let conf = tsModule.conf;
            // Ptl 检测 Req 和 Res 类型齐全
            if (match[2] === 'Ptl') {
                let req = typePath + '/Req' + match[3];
                let res = typePath + '/Res' + match[3];
                if (typeProto[req] && typeProto[res]) {
                    services.push({
                        id: services.length,
                        name: (match[1] || '') + match[3],
                        type: 'api',
                        conf: conf
                    });
                }
                else {
                    !typeProto[res] && errMsgs.push(chalk__default["default"].red(`⨯ Missing type ${chalk__default["default"].cyan(`Res${match[3]}`)} at ${chalk__default["default"].cyan(filepath)}`));
                    !typeProto[req] && errMsgs.push(chalk__default["default"].red(`⨯ Missing type ${chalk__default["default"].cyan(`Req${match[3]}`)} at ${chalk__default["default"].cyan(filepath)}`));
                }
            }
            // Msg 检测Msg类型在
            else {
                let msg = typePath + '/Msg' + match[3];
                if (typeProto[msg]) {
                    services.push({
                        id: services.length,
                        name: (match[1] || '') + match[3],
                        type: 'msg',
                        conf: conf
                    });
                }
                else {
                    errMsgs.push(chalk__default["default"].red(`⨯ Missing type ${chalk__default["default"].cyan(`Msg${match[3]}`)} at ${chalk__default["default"].cyan}`));
                }
            }
        }
        // 有 Missing 报错，不生成
        if (errMsgs.length) {
            throw new Error(errMsgs.join('\n'));
        }
        // 检测可优化的 ID 冗余
        let canOptimizeByNew = false;
        tsbufferProtoGenerator.EncodeIdUtil.onGenCanOptimized = () => {
            canOptimizeByNew = true;
        };
        // EncodeID 兼容 OldProto
        let encodeIds = tsbufferProtoGenerator.EncodeIdUtil.genEncodeIds(services.map(v => v.type + v.name), oldProto === null || oldProto === void 0 ? void 0 : oldProto.services.map(v => ({
            key: v.type + v.name,
            id: v.id
        })));
        for (let item of encodeIds) {
            services.find(v => item.key.startsWith(v.type) && v.name === item.key.substr(v.type.length)).id = item.id;
        }
        let version = oldProto === null || oldProto === void 0 ? void 0 : oldProto.version;
        // 只有在旧 Proto 存在，同时协议内容变化的情况下，才更新版本号
        if (oldProto && JSON.stringify({ types: oldProto.types, services: oldProto.services }) !== JSON.stringify({ types: typeProto, services: services })) {
            version = (oldProto.version || 0) + 1;
        }
        // 创建新 Proto
        let newProto = {
            version: version,
            services: services,
            types: typeProto
        };
        // process.chdir(originalCwd);
        if (options.checkOptimize && canOptimizeByNew && ((_b = options.oldProto) === null || _b === void 0 ? void 0 : _b.path)) {
            console.warn(chalk__default["default"].yellow(i18n.canOptimizeByNew(path__default["default"].resolve(options.oldProto.path)) + '\n'));
        }
        return {
            newProto: newProto,
            isChanged: newProto.version !== (oldProto === null || oldProto === void 0 ? void 0 : oldProto.version)
        };
    }
    static async outputProto(options, logger) {
        if (options.noEmitWhenNoChange) {
            // TS 报错也算需要重新生成
            let oldProto = await this.loadServiceProto(options.newProtoPath, undefined, false);
            if (oldProto && JSON.stringify(oldProto) === JSON.stringify(options.proto)) {
                return { emited: false };
            }
        }
        // TS
        if (options.newProtoPath.endsWith('.ts')) {
            let imports = {};
            let apis = [];
            let msgs = [];
            // 防止重名
            let usedNames = {};
            let getAsName = (name) => {
                while (usedNames[name]) {
                    let match = name.match(/(^.*)\_(\d+)$/);
                    if (match) {
                        let seq = parseInt(match[2]) + 1;
                        name = match[1] + '_' + seq;
                    }
                    else {
                        name = name + '_1';
                    }
                }
                usedNames[name] = 1;
                return name;
            };
            let addImport = (path, srcNames) => {
                let asNames = srcNames.map(v => getAsName(v));
                imports[path] = srcNames.map((v, i) => ({
                    srcName: v,
                    asName: asNames[i] && asNames[i] !== v ? asNames[i] : undefined
                }));
                return asNames;
            };
            for (let svc of options.proto.services) {
                let match = svc.name.replace(/\\/g, '/').match(/^(.*\/)*([^\/]+)$/);
                if (!match) {
                    throw new Error(`Invalid svc name: ${svc.name}`);
                }
                let lastName = match[2];
                let importPath = path__default["default"].relative(path__default["default"].dirname(options.newProtoPath), path__default["default"].join(options.protocolDir, (match[1] || '') + (svc.type === 'api' ? 'Ptl' : 'Msg') + lastName)).replace(/\\/g, '/');
                if (!importPath.startsWith('.')) {
                    importPath = './' + importPath;
                }
                if (svc.type === 'api') {
                    let op = addImport(importPath, ['Req' + lastName, 'Res' + lastName]);
                    apis.push({
                        name: svc.name,
                        importPath: importPath,
                        req: op[0],
                        res: op[1]
                    });
                }
                else {
                    let op = addImport(importPath, ['Msg' + lastName]);
                    msgs.push({
                        name: svc.name,
                        importPath: importPath,
                        msg: op[0]
                    });
                }
            }
            let importStr = Object.entries(imports)
                .map(v => `import { ${v[1].map(w => w.asName ? `${w.srcName} as ${w.asName}` : w.srcName).join(', ')} } from '${v[0]}';`)
                .join('\n');
            let apiStr = apis.map(v => `        ${JSON.stringify(v.name)}: {
            req: ${v.req},
            res: ${v.res}
        }`).join(',\n');
            let msgStr = msgs.map(v => `        ${JSON.stringify(v.name)}: ${v.msg}`).join(',\n');
            let fileContent = `
import { ServiceProto } from 'tsrpc-proto';
${importStr}

export interface ServiceType {
    api: {
${apiStr}
    },
    msg: {
${msgStr}
    }
}

export const serviceProto: ServiceProto<ServiceType> = ${JSON.stringify(options.proto, null, 4)};
`.trim();
            await fs__default$1["default"].ensureDir(path__default["default"].dirname(options.newProtoPath));
            await fs__default$1["default"].writeFile(options.newProtoPath, fileContent);
        }
        // JSON
        else {
            await fs__default$1["default"].ensureDir(path__default["default"].dirname(options.newProtoPath));
            await fs__default$1["default"].writeFile(options.newProtoPath, options.ugly ? JSON.stringify(options.proto) : JSON.stringify(options.proto, null, 2));
        }
        logger === null || logger === void 0 ? void 0 : logger.log(chalk__default["default"].green(formatStr(i18n.protoSucc, { output: path__default["default"].resolve(options.newProtoPath) })));
        return { emited: true };
    }
    static async loadOldProtoByConfigItem(confItem, verbose) {
        var _a;
        // old
        let oldProtoPath = (_a = confItem.compatible) !== null && _a !== void 0 ? _a : confItem.output;
        let oldProto;
        if (oldProtoPath) {
            oldProto = await ProtoUtil.loadServiceProto(oldProtoPath, verbose ? console : undefined);
        }
        verbose && console.log(`oldProtoPath: ${oldProtoPath}, hasOldProto=${!!oldProto}`);
        return oldProto ? {
            proto: oldProto,
            path: oldProtoPath
        } : undefined;
    }
    static async genProtoByConfigItem(confItem, old, verbose, checkOptimize, noEmitWhenNoChange, keepComment) {
        // new
        try {
            var resGenProto = await ProtoUtil.generateServiceProto({
                protocolDir: confItem.ptlDir,
                oldProto: old,
                ignore: confItem.ignore,
                verbose: verbose,
                checkOptimize: checkOptimize
            });
            verbose && console.log(`Proto generated succ, start to write output file...`);
        }
        catch (e) {
            console.error(chalk__default["default"].red(e.message));
            throw new Error(i18n.protoFailed(confItem.output));
        }
        // output
        await ProtoUtil.outputProto({
            protocolDir: confItem.ptlDir,
            newProtoPath: confItem.output,
            proto: resGenProto.newProto,
            noEmitWhenNoChange: noEmitWhenNoChange
        }, console);
        verbose && console.log(`Finish: ${confItem.output}...`);
        return resGenProto.newProto;
    }
    static toJsonSchema() { }
}

async function cmdApi(options) {
    var _a;
    if (options.config) {
        if (!options.config.proto) {
            throw new Error(i18n.missingConfigItem('proto'));
        }
        let newCount = 0;
        for (let conf of options.config.proto) {
            if (!conf.apiDir) {
                continue;
            }
            let proto = await ProtoUtil.loadServiceProto(conf.output, options.config.verbose ? console : undefined);
            if (!proto) {
                console.warn(chalk__default["default"].yellow(formatStr(i18n.protoParsedError, { file: path__default["default"].resolve(conf.output) })));
                continue;
            }
            let res = await genApiFilesByProto({
                proto: proto,
                ptlDir: conf.ptlDir,
                apiDir: conf.apiDir,
                template: (_a = conf.newApiTemplate) !== null && _a !== void 0 ? _a : CodeTemplate.defaultApi
            }, console);
            newCount += res.length;
        }
        console.log(chalk__default["default"].green(formatStr(i18n.allApiSucc, { newCount: '' + newCount })));
    }
    else {
        if (!options.input) {
            throw console$1.error(i18n.missingParam, { param: 'input' });
        }
        if (!options.output) {
            throw console$1.error(i18n.missingParam, { param: 'output' });
        }
        let proto = await ProtoUtil.loadServiceProto(options.input);
        if (!proto) {
            throw console$1.error(i18n.protoParsedError, { file: options.input });
        }
        let res = await genApiFilesByProto({
            proto: proto,
            ptlDir: path__default["default"].dirname(options.input),
            apiDir: options.output,
            template: undefined
        }, console);
        console.log(chalk__default["default"].green(formatStr(i18n.allApiSucc, { newCount: '' + res.length })));
    }
}
function getApiFileInfo(apiSvcName, apiDir, ptlDir) {
    let apiBaseName = apiSvcName.match(/\w+$/)[0];
    /** a/b/c/Test  apiBaseName='Test' apiBasePath='a/b/c/' */
    let apiBasePath = apiSvcName.substr(0, apiSvcName.length - apiBaseName.length);
    /** API src files dir */
    let apiFileDir = path__default["default"].join(apiDir, apiBasePath);
    /** API src .ts file pathname */
    let apiFilePath = path__default["default"].join(apiFileDir, `Api${apiBaseName}.ts`);
    /** Ptl src files dir */
    let ptlFileDir = path__default["default"].join(ptlDir, apiBasePath);
    return {
        apiBaseName,
        apiBasePath,
        apiFileDir,
        apiFilePath,
        ptlFileDir
    };
}
async function genApiFilesByProto(options, logger) {
    var _a;
    let apis = options.proto.services.filter(v => v.type === 'api');
    let generatedFiles = [];
    for (let api of apis) {
        let { apiBaseName, apiFilePath, apiFileDir, ptlFileDir } = getApiFileInfo(api.name, options.apiDir, options.ptlDir);
        await genNewApiFile(apiBaseName, apiFilePath, apiFileDir, ptlFileDir, (_a = options.template) !== null && _a !== void 0 ? _a : CodeTemplate.defaultApi);
        generatedFiles.push({ apiFilePath: apiFilePath, apiBaseName: apiBaseName });
        logger === null || logger === void 0 ? void 0 : logger.log(chalk__default["default"].green(formatStr(i18n.apiSucc, { apiPath: apiFilePath, apiName: apiBaseName })));
    }
    return generatedFiles;
}
async function genNewApiFile(apiBaseName, apiFilePath, apiFileDir, ptlFileDir, template) {
    /** Files exists already, skip */
    if (!await fs__default$1["default"].access(apiFilePath).catch(() => true)) {
        return;
    }
    await fs__default$1["default"].ensureDir(path__default["default"].dirname(apiFilePath));
    await fs__default$1["default"].writeFile(apiFilePath, template(apiBaseName, apiFileDir, ptlFileDir), { encoding: 'utf-8' });
}

class CliUtil {
    static doing(text, doingPostFix = '...') {
        if (this.currentDoingText !== undefined) {
            this.spinner.stop();
        }
        this.currentDoingText = text;
        this.spinner.text = chalk__default["default"].yellow(`${text}${doingPostFix}\n`);
        this.spinner.start();
    }
    static done(succ = true, text) {
        if (this.currentDoingText !== undefined) {
            text = `${text !== null && text !== void 0 ? text : this.currentDoingText}`;
            succ ? this.spinner.succeed(chalk__default["default"].green(text)) : this.spinner.fail(chalk__default["default"].red(text));
            this.currentDoingText = undefined;
        }
    }
    static clear() {
        this.spinner.stop();
        this.currentDoingText = undefined;
    }
}
CliUtil.spinner = ora__default["default"]('');

async function cmdLink(options) {
    var _a;
    if (options.config) {
        if (!((_a = options.config.sync) === null || _a === void 0 ? void 0 : _a.length)) {
            console.log(chalk__default["default"].yellow(i18n.nothingSyncConf));
            return;
        }
        let linkConfs = options.config.sync.filter(v => v.type === 'symlink');
        await ensureSymlinks(linkConfs.map(v => ({
            src: v.from,
            dst: v.to
        })), console);
        console.log(chalk__default["default"].green(i18n.allLinkedSucc));
    }
    else if (options.elevate) {
        let confs = JSON.parse(decodeURIComponent(options.elevate));
        await ensureSymlinks(confs, console, true);
    }
    else {
        // Validate options
        if (!options.from) {
            throw error(i18n.missingParam, { param: 'from' });
        }
        if (!options.to) {
            throw error(i18n.missingParam, { param: 'to' });
        }
        await ensureSymlinks([{
                src: options.from,
                dst: options.to
            }], console);
        console.log(chalk__default["default"].green(i18n.linkedSucc));
    }
}
async function ensureSymlinks(confs, logger, isElevate) {
    // 通过 elevate 运行的结果，undefined 代表尚未通过 elevate 运行
    let elevateResult;
    let createJunction;
    let isAllSucc = true;
    for (let conf of confs) {
        let { src, dst } = conf;
        src = path__default["default"].resolve(src);
        dst = path__default["default"].resolve(dst);
        if (elevateResult) {
            logger === null || logger === void 0 ? void 0 : logger.log(`✔ ${createJunction ? i18n.junction : i18n.link} ${src} -> ${dst}`);
            continue;
        }
        // 检查 dst 上级目录存在
        const dstParent = path__default["default"].dirname(dst);
        if (!(await fs__default$1["default"].access(dstParent).then(() => true).catch(() => false))) {
            logger === null || logger === void 0 ? void 0 : logger.log(chalk__default["default"].yellow(`✘ ${i18n.link} ${src} -> ${dst}\n  |- ${formatStr(i18n.dirNotExists, { dir: dstParent })}`));
            isAllSucc = false;
            continue;
        }
        await fs__default$1["default"].ensureDir(src);
        // dst 已存在 Symlink
        if ((await fs__default$1["default"].access(dst).then(() => true).catch(() => false)) && (await fs__default$1["default"].lstat(dst)).isSymbolicLink()) {
            // 检查 symlink 的 destination 是否正确
            const oriCwd = process.cwd();
            process.chdir(path__default["default"].dirname(dst));
            const symlinkDst = path__default["default"].resolve(await fs__default$1["default"].readlink(dst));
            process.chdir(oriCwd);
            // dst symlink 目标路径有误（可能因为移动目录导致），删除之（后面重新创建）
            if (symlinkDst !== src) {
                await fs__default$1["default"].remove(dst);
            }
        }
        // Try first time
        let err = await fs__default$1["default"].ensureSymlink(src, dst, createJunction ? 'junction' : 'dir').catch(e => e);
        // 创建失败（文件已存在）
        if ((err === null || err === void 0 ? void 0 : err.code) === 'EEXIST') {
            // 删除
            await fs__default$1["default"].remove(dst);
            // 然后重试
            err = await fs__default$1["default"].ensureSymlink(src, dst, createJunction ? 'junction' : 'dir').catch(e => e);
        }
        // Windows 下无权限
        if (!isElevate && process.platform === 'win32' && (err === null || err === void 0 ? void 0 : err.code) === 'EPERM') {
            // 尚未尝试过提权，提权重试
            while (elevateResult === undefined) {
                // 提权执行
                let elevateCmd = `"${path__default["default"].resolve(resPath, 'elevate.cmd')}" "${process.execPath}" ${process.execArgv.join(' ')} "${process.argv[1]}" link --elevate="${encodeURIComponent(JSON.stringify(confs))}"`;
                await new Promise(rs => {
                    childProcess.exec(elevateCmd).on('close', rs);
                });
                // 由于 elevate 的调起机制，无法获取返回结果
                // 所以通过轮询来检测，最多等待 5 秒
                CliUtil.doing(i18n.elevatingForLink);
                let startTime = Date.now();
                while (Date.now() - startTime <= 5000) {
                    // 普通重试，验证提权结果
                    err = await fs__default$1["default"].ensureSymlink(src, dst, 'dir').catch(e => e);
                    elevateResult = (err === null || err === void 0 ? void 0 : err.code) !== 'EPERM';
                    if (elevateResult) {
                        break;
                    }
                    else {
                        await new Promise(rs => setTimeout(rs, 500));
                    }
                }
                CliUtil.done(!!elevateResult);
                // 提权失败，询问是否创建 junction
                if (!elevateResult) {
                    let answer = (await inquirer__default["default"].prompt({
                        type: 'list',
                        message: chalk__default["default"].yellow(i18n.linkFailed),
                        choices: [
                            { name: i18n.linkRetry, value: 'retry' },
                            { name: i18n.linkJunction, value: 'junction' },
                        ],
                        name: 'res'
                    })).res;
                    // 清除结果，重试
                    if (answer === 'retry') {
                        elevateResult = undefined;
                    }
                    // 改为创建 Junction·
                    else {
                        createJunction = true;
                    }
                }
            }
            // 提权失败，创建 junction
            if (elevateResult === false && createJunction) {
                err = await fs__default$1["default"].ensureSymlink(src, dst, 'junction').catch(e => e);
            }
        }
        // Fail
        if (err) {
            if (isElevate) {
                continue;
            }
            else {
                throw err;
            }
        }
        // Success
        logger === null || logger === void 0 ? void 0 : logger.log(chalk__default["default"].green(`✔ ${createJunction ? i18n.junction : i18n.link} ${src} -> ${dst}`));
    }
    return { isAllSucc: isAllSucc };
}

async function cmdSync(options) {
    var _a;
    if (options.config) {
        if (!((_a = options.config.sync) === null || _a === void 0 ? void 0 : _a.length)) {
            console.log(chalk__default["default"].yellow(i18n.nothingSyncConf));
            return;
        }
        await syncByConfig(options.config.sync, options.config.verbose ? console : undefined);
        console.log(chalk__default["default"].green(i18n.allSyncedSucc));
    }
    else {
        // Validate options
        if (!options.from) {
            throw error(i18n.missingParam, { param: 'from' });
        }
        if (!options.to) {
            throw error(i18n.missingParam, { param: 'to' });
        }
        if (await fs__default$1["default"].access(options.from).catch(() => true)) {
            throw error(i18n.dirNotExists, { dir: path__default["default"].resolve(options.from) });
        }
        CliUtil.doing(`${i18n.copy} '${path__default["default"].resolve(options.from)}' -> '${path__default["default"].resolve(options.to)}'`);
        await copyDirReadonly(options.from, options.to, true, options.verbose ? console : undefined);
        CliUtil.done(true);
        console.log(chalk__default["default"].green(i18n.syncedSucc));
    }
}
async function syncByConfig(syncConfig, logger) {
    if (!syncConfig.length) {
        return;
    }
    // Copy
    for (let item of syncConfig) {
        if (item.type === 'copy') {
            CliUtil.doing(`${i18n.copy} '${item.from}' -> '${item.to}'`);
            await copyDirReadonly(item.from, item.to, !!item.clean, logger);
            CliUtil.done(true);
        }
    }
    // Symlinks
    await ensureSymlinks(syncConfig.filter(v => v.type === 'symlink').map(v => ({
        src: v.from,
        dst: v.to
    })), console);
}
async function copyDirReadonly(src, dst, clean, logger) {
    // Clean
    if (clean) {
        logger === null || logger === void 0 ? void 0 : logger.debug(`Start to clean '${dst}'`);
        await fs__default$1["default"].remove(dst);
        logger === null || logger === void 0 ? void 0 : logger.debug(`Cleaned succ`);
    }
    // Copy
    logger === null || logger === void 0 ? void 0 : logger.debug(`Start to copy '${src}' to '${dst}'`);
    await fs__default$1["default"].ensureDir(dst);
    await fs__default$1["default"].copy(src, dst);
    logger === null || logger === void 0 ? void 0 : logger.debug('Copyed succ');
    // Readonly (chmod 0o444)
    setReadonlyRecursive(dst, logger);
}
async function setReadonlyRecursive(dst, logger) {
    logger === null || logger === void 0 ? void 0 : logger.debug(`Start to setReadonlyRecursive to '${dst}'`);
    let items = await new Promise((rs, rj) => {
        glob.glob(path__default["default"].resolve(dst, '**'), (err, matches) => {
            err ? rj() : rs(matches);
        });
    });
    for (let item of items) {
        let stat = fs__default$1["default"].statSync(item);
        if (stat.isFile()) {
            await fs__default$1["default"].chmod(item, 0o444);
            logger === null || logger === void 0 ? void 0 : logger.log(chalk__default["default"].green('chmod 444: ' + item));
        }
    }
    logger === null || logger === void 0 ? void 0 : logger.debug('setReadonlyRecursive succ');
}

async function cmdBuild(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const outDir = path__default["default"].resolve((_c = (_b = (_a = options.config) === null || _a === void 0 ? void 0 : _a.build) === null || _b === void 0 ? void 0 : _b.outDir) !== null && _c !== void 0 ? _c : 'dist');
    if (options.config) {
        const autoProto = (_e = (_d = options.config.build) === null || _d === void 0 ? void 0 : _d.autoProto) !== null && _e !== void 0 ? _e : true;
        const autoSync = (_g = (_f = options.config.build) === null || _f === void 0 ? void 0 : _f.autoSync) !== null && _g !== void 0 ? _g : true;
        const autoApi = (_j = (_h = options.config.build) === null || _h === void 0 ? void 0 : _h.autoApi) !== null && _j !== void 0 ? _j : true;
        // Auto Proto
        if (autoProto && options.config.proto) {
            for (let confItem of options.config.proto) {
                // old
                let old = await ProtoUtil.loadOldProtoByConfigItem(confItem, options.config.verbose);
                // new
                let newProto = await ProtoUtil.genProtoByConfigItem(confItem, old, options.config.verbose, options.config.checkOptimizableProto, true);
                // Auto API
                if (autoApi && newProto && confItem.apiDir) {
                    await genApiFilesByProto({
                        proto: newProto,
                        ptlDir: confItem.ptlDir,
                        apiDir: confItem.apiDir,
                        template: confItem.newApiTemplate
                    });
                }
            }
        }
        // Auto Sync
        if (autoSync && options.config.sync) {
            const logger = options.config.verbose ? console : undefined;
            await syncByConfig(options.config.sync, logger);
        }
    }
    // clean
    CliUtil.doing(i18n.buildClean(outDir));
    await fs__default$1["default"].remove(outDir);
    CliUtil.done();
    // tsc
    CliUtil.doing(i18n.buildTsc, '...');
    await new Promise((rs, rj) => {
        let cp = childProcess__default["default"].spawn('npx', ['tsc'], {
            stdio: 'inherit',
            shell: true
        });
        cp.on('exit', code => {
            if (code) {
                CliUtil.clear();
                rj(error(i18n.codeError));
            }
            else {
                rs();
            }
        });
    });
    CliUtil.done();
    // Copy files
    CliUtil.doing(i18n.buildCopyFiles);
    fs__default$1["default"].existsSync('package-lock.json') && fs__default$1["default"].copyFileSync('package-lock.json', 'dist/package-lock.json');
    fs__default$1["default"].existsSync('yarn.lock') && fs__default$1["default"].copyFileSync('yarn.lock', 'dist/yarn.lock');
    // package.json
    let packageJSON = JSON.parse(fs__default$1["default"].readFileSync('package.json', 'utf-8'));
    packageJSON.scripts = {
        ...packageJSON.scripts,
        start: (_k = packageJSON.scripts.start) !== null && _k !== void 0 ? _k : 'node index.js'
    };
    // remove dev scripts
    ['proto', 'sync', 'link', 'api', 'dev', 'build'].forEach(key => {
        delete packageJSON.scripts[key];
    });
    fs__default$1["default"].writeFileSync('dist/package.json', JSON.stringify(packageJSON, null, 2), 'utf-8');
    CliUtil.done();
    console.log(`\n ${chalk__default["default"].bgGreen.white(i18n.buildSucc)} `);
}

async function cmdDecode(options) {
    let parsedProto = await ProtoUtil.parseProtoAndSchema(options.protoPath, options.schemaId);
    let inputBuf;
    if (options.input) {
        try {
            inputBuf = fs__default["default"].readFileSync(options.input);
        }
        catch (e) {
            options.verbose && console.error(e);
            throw console$1.error(i18n.fileOpenError, { file: path__default["default"].resolve(options.input) });
        }
    }
    else if (options.binStr) {
        inputBuf = hex2Bin(options.binStr);
    }
    else {
        throw console$1.error(i18n.missingParam, { param: `--input ${i18n.or} [binstr]` });
    }
    let decodedValue;
    try {
        decodedValue = new tsbuffer.TSBuffer(parsedProto.proto).decode(new Uint8Array(inputBuf), parsedProto.schemaId);
    }
    catch (e) {
        throw console$1.error('解码失败:\n    ' + e.message);
    }
    if (options.output) {
        fs__default["default"].writeFileSync(options.output, JSON.stringify(decodedValue, null, 2));
        console.log(chalk__default["default"].green(formatStr(i18n.decodeSucc, { output: options.output })));
    }
    else {
        console.log(colorJson(decodedValue));
    }
}

const DEFAULT_DELAY = 1000;
async function cmdDev(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
    let conf = options.config;
    const autoProto = (_b = (_a = conf.dev) === null || _a === void 0 ? void 0 : _a.autoProto) !== null && _b !== void 0 ? _b : true;
    const autoSync = (_d = (_c = conf.dev) === null || _c === void 0 ? void 0 : _c.autoSync) !== null && _d !== void 0 ? _d : true;
    const autoApi = (_f = (_e = conf.dev) === null || _e === void 0 ? void 0 : _e.autoApi) !== null && _f !== void 0 ? _f : true;
    const entry = (_j = (_g = options.entry) !== null && _g !== void 0 ? _g : (_h = conf.dev) === null || _h === void 0 ? void 0 : _h.entry) !== null && _j !== void 0 ? _j : 'src/index.ts';
    const devServerArgs = ['-r', 'ts-node/register', ...((_l = (_k = conf.dev) === null || _k === void 0 ? void 0 : _k.nodeArgs) !== null && _l !== void 0 ? _l : []), entry];
    const cmdStart = 'node ' + devServerArgs.map(v => /\s/.test(v) ? `'${v}'` : v).join(' ');
    const watchFiles = (_o = (_m = conf.dev) === null || _m === void 0 ? void 0 : _m.watch) !== null && _o !== void 0 ? _o : 'src';
    let protoErr = {};
    // 启动前 sync 一次
    if (conf.sync && autoSync) {
        await syncByConfig(conf.sync, conf.verbose ? console : undefined);
    }
    // Auto Copy if target is a file (maybe a link)
    let firstSyncedIndices = [];
    if (conf.sync) {
        let copyConfs = conf.sync.filter(v => v.type === 'copy');
        for (let i = 0; i < copyConfs.length; ++i) {
            let conf = copyConfs[i];
            let lstat = await fs__default$1["default"].lstat(conf.to);
            if (lstat.isSymbolicLink() || lstat.isFile()) {
                await fs__default$1["default"].remove(conf.to);
                await copyDirReadonly(conf.from, conf.to, !!conf.clean, options.config.verbose ? console : undefined);
                console.log(chalk__default["default"].green(`✔ ${i18n.copy} '${conf.from}' -> '${conf.to}'`));
                firstSyncedIndices.push(i);
            }
        }
    }
    // Auto Proto
    if (autoProto && conf.proto) {
        for (let confItem of conf.proto) {
            const protoPath = path__default["default"].resolve(confItem.output);
            // 启动前执行一次填充
            await fillAllPtlAndMsgs(confItem, autoApi);
            // old
            let old = await ProtoUtil.loadOldProtoByConfigItem(confItem, options.config.verbose);
            const onAutoProtoTrigger = async () => {
                let newProto = await ProtoUtil.genProtoByConfigItem(confItem, old, options.config.verbose, options.config.checkOptimizableProto, true).catch(e => {
                    // 插入错误记录
                    protoErr[protoPath] = e.message;
                    console.error(chalk__default["default"].red(e.message));
                    return undefined;
                });
                // 生成成功，清除错误记录
                if (newProto) {
                    delete protoErr[protoPath];
                }
            };
            delayWatch({
                matches: (_p = confItem.watch) !== null && _p !== void 0 ? _p : watchFiles,
                ignore: [confItem.output, ...(confItem.compatible ? [confItem.compatible] : []), ...((_q = confItem.ignore) !== null && _q !== void 0 ? _q : [])],
                onChange: async (eventName, filepath, stats) => {
                    var _a, _b, _c, _d;
                    // 该文件不是 Msg 或 Ptl，跳过
                    let match = path__default["default"].basename(filepath).match(/^(Ptl|Msg)(\w+)\.ts$/);
                    if (!match) {
                        return;
                    }
                    // 该文件不在 ptlDir 下，跳过
                    if (path__default["default"].relative(confItem.ptlDir, filepath).startsWith('..')) {
                        return;
                    }
                    let type = match[1];
                    let basename = match[2];
                    // Auto fill new Ptl or Msg
                    if (((_b = (_a = conf.dev) === null || _a === void 0 ? void 0 : _a.autoFillNewPtl) !== null && _b !== void 0 ? _b : true) && eventName === 'add') {
                        await fillNewPtlOrMsg(filepath, confItem, { type, basename });
                    }
                    // Auto Api
                    if (autoApi && confItem.apiDir && type === 'Ptl') {
                        let apiFilePath = path__default["default"].join(confItem.apiDir, path__default["default"].relative(confItem.ptlDir, path__default["default"].join(path__default["default"].dirname(filepath), `Api${basename}.ts`)));
                        let emptyApiContent = ((_c = confItem.apiTemplate) !== null && _c !== void 0 ? _c : CodeTemplate.defaultApi)(basename, path__default["default"].dirname(apiFilePath), path__default["default"].dirname(filepath));
                        // Auto generate new API
                        if (eventName === 'add') {
                            await genNewApiFile(basename, apiFilePath, path__default["default"].dirname(apiFilePath), path__default["default"].dirname(filepath), (_d = confItem.apiTemplate) !== null && _d !== void 0 ? _d : CodeTemplate.defaultApi).catch();
                        }
                        // Auto remove unchanged API
                        if (eventName === 'unlink') {
                            // File not exists
                            if (await fs__default$1["default"].access(apiFilePath).catch(() => true)) {
                                return;
                            }
                            // Compare, only remove when it is unchanged
                            let apiContent = await fs__default$1["default"].readFile(apiFilePath, 'utf-8').catch(() => undefined);
                            if ((apiContent === null || apiContent === void 0 ? void 0 : apiContent.length) === 0 || apiContent === emptyApiContent) {
                                await fs__default$1["default"].remove(apiFilePath).catch();
                            }
                        }
                    }
                },
                onTrigger: onAutoProtoTrigger,
                delay: (_s = (_r = conf.dev) === null || _r === void 0 ? void 0 : _r.delay) !== null && _s !== void 0 ? _s : DEFAULT_DELAY,
                watchId: `AutoProto_${conf.proto.indexOf(confItem)}`,
            });
            await onAutoProtoTrigger();
        }
    }
    // Auto Copy
    if (autoSync) {
        (_t = conf.sync) === null || _t === void 0 ? void 0 : _t.forEach((confItem, idx) => {
            var _a, _b;
            if (confItem.type !== 'copy') {
                return;
            }
            let isInited = firstSyncedIndices.indexOf(idx) > -1;
            delayWatch({
                matches: confItem.from,
                onTrigger: async (eventName, filepath, stats) => {
                    // 仅第一次全量
                    if (!isInited) {
                        await copyDirReadonly(confItem.from, confItem.to, !!confItem.clean, options.config.verbose ? console : undefined);
                        console.log(chalk__default["default"].green(`✔ ${i18n.copy} '${confItem.from}' -> '${confItem.to}'`));
                        isInited = true;
                    }
                    // 后续改为增量
                    else {
                        const dstPath = path__default["default"].resolve(confItem.to, path__default["default"].relative(confItem.from, filepath));
                        // 删除
                        if (eventName.startsWith('unlink')) {
                            await fs__default$1["default"].remove(dstPath);
                        }
                        // 重新复制
                        else {
                            await fs__default$1["default"].copy(filepath, dstPath);
                            if (!eventName.endsWith('Dir')) {
                                await fs__default$1["default"].chmod(dstPath, 0o444);
                            }
                            console.log(chalk__default["default"].green(`✔ ${i18n.copy} '${filepath}' -> '${dstPath}'`));
                        }
                    }
                },
                delay: (_b = (_a = conf.dev) === null || _a === void 0 ? void 0 : _a.delay) !== null && _b !== void 0 ? _b : DEFAULT_DELAY,
                watchId: `AutoSync_${idx}`,
            });
        });
    }
    // dev server
    let devServer;
    let devServerRestartTimes = 0;
    const startDevServer = async () => {
        let restartTimes = devServerRestartTimes;
        // 延迟一会，如果没有新的重启请求，则执行重启
        await new Promise(rs => setTimeout(rs, 200));
        if (devServerRestartTimes !== restartTimes) {
            return;
        }
        // 有 Proto 生成错误时，始终不启动 devServer
        for (let protoPath in protoErr) {
            if (protoErr[protoPath]) {
                console.error(chalk__default["default"].yellow(i18n.protoNotReady + '\n'));
                return;
            }
        }
        console.log(`${chalk__default["default"].green(i18n.startDevServer)} ${chalk__default["default"].cyan(cmdStart)}\n`);
        devServer = childProcess.spawn('node', devServerArgs, {
            stdio: 'inherit'
        });
        devServer.once('exit', () => {
            console.log(chalk__default["default"].red.bold(i18n.devServerStopped));
        });
    };
    delayWatch({
        matches: watchFiles,
        onWillTrigger: async () => {
            ++devServerRestartTimes;
            if (devServer) {
                console.log(chalk__default["default"].yellow(i18n.devServerRestarting));
                // 还在运行中，kill 之
                if (devServer.exitCode == null) {
                    await new Promise(rs => {
                        devServer.removeAllListeners('exit');
                        devServer.once('exit', rs);
                        devServer.kill();
                    });
                }
            }
            devServer = undefined;
        },
        onTrigger: () => {
            startDevServer();
        },
        delay: (_v = (_u = conf.dev) === null || _u === void 0 ? void 0 : _u.delay) !== null && _v !== void 0 ? _v : DEFAULT_DELAY,
        watchId: 'DEV_SERVER',
    });
    startDevServer();
}
function delayWatch(options) {
    let timer;
    // Real file change handler，禁止并发
    let isProcessing = false;
    const onWillTrigger = async (eventName, filepath, stats) => {
        var _a, _b;
        (_a = options.onChange) === null || _a === void 0 ? void 0 : _a.call(options, eventName, filepath, stats);
        if (isProcessing) {
            return;
        }
        isProcessing = true;
        // clear last timer
        if (timer) {
            clearTimeout(timer);
            timer = undefined;
        }
        // 只在此变化循环中，第一次变化时，触发onWillTrigger
        else {
            await ((_b = options.onWillTrigger) === null || _b === void 0 ? void 0 : _b.call(options, eventName, filepath, stats));
        }
        // set new delay timer
        timer = setTimeout(() => {
            var _a;
            timer = undefined;
            (_a = options.onTrigger) === null || _a === void 0 ? void 0 : _a.call(options, eventName, filepath, stats);
        }, options.delay);
        isProcessing = false;
    };
    chokidar__default["default"].watch(options.matches, {
        ignored: options.ignore,
        ignoreInitial: true
    }).on('all', onWillTrigger);
}
async function fillNewPtlOrMsg(filepath, confItem, parsed) {
    var _a, _b;
    // 只写入空白文件
    let content = await fs__default$1["default"].readFile(filepath);
    if (content.length > 0) {
        return false;
    }
    if (!parsed) {
        let match = path__default["default"].basename(filepath).match(/^(Ptl|Msg)(\w+)\.ts$/);
        if (!match) {
            return false;
        }
        parsed = {
            type: match[1],
            basename: match[2],
        };
    }
    if (parsed.type === 'Ptl') {
        await fs__default$1["default"].writeFile(filepath, ((_a = confItem.ptlTemplate) !== null && _a !== void 0 ? _a : CodeTemplate.defaultPtl)(parsed.basename, filepath, confItem.ptlDir), 'utf-8');
    }
    else if (parsed.type === 'Msg') {
        await fs__default$1["default"].writeFile(filepath, ((_b = confItem.msgTemplate) !== null && _b !== void 0 ? _b : CodeTemplate.defaultMsg)(parsed.basename, filepath, confItem.ptlDir), 'utf-8');
    }
    return true;
}
async function fillAllPtlAndMsgs(confItem, autoApi = false) {
    var _a;
    let files = await new Promise((rs, rj) => {
        glob.glob(path__default["default"].resolve(path__default["default"].resolve(confItem.ptlDir, '**/{Ptl,Msg}?*.ts')), (err, matches) => {
            if (err) {
                rj(err);
            }
            else {
                rs(matches);
            }
        });
    });
    for (let file of files) {
        await fillNewPtlOrMsg(file, confItem);
        let match = path__default["default"].basename(file).match(/^(Ptl|Msg)(\w+)\.ts$/);
        let type = match[1];
        let basename = match[2];
        if (autoApi && type === 'Ptl' && confItem.apiDir) {
            let apiFilePath = path__default["default"].join(confItem.apiDir, path__default["default"].relative(confItem.ptlDir, path__default["default"].join(path__default["default"].dirname(file), `Api${basename}.ts`)));
            await genNewApiFile(basename, apiFilePath, path__default["default"].dirname(apiFilePath), path__default["default"].dirname(file), (_a = confItem.apiTemplate) !== null && _a !== void 0 ? _a : CodeTemplate.defaultApi).catch();
        }
    }
}

/** A utility for generate `ServiceMap` */
class ServiceMapUtil {
    static getServiceMap(proto) {
        let map = {
            id2Service: {},
            apiName2Service: {},
            msgName2Service: {}
        };
        for (let v of proto.services) {
            let match = v.name.match(/(.+\/)?([^\/]+)$/);
            let path = match[1] || '';
            let name = match[2];
            if (v.type === 'api') {
                let svc = {
                    ...v,
                    reqSchemaId: `${path}Ptl${name}/Req${name}`,
                    resSchemaId: `${path}Ptl${name}/Res${name}`,
                };
                map.apiName2Service[v.name] = svc;
                map.id2Service[v.id] = svc;
            }
            else {
                let svc = {
                    ...v,
                    msgSchemaId: `${path}Msg${name}/Msg${name}`,
                };
                map.msgName2Service[v.name] = svc;
                map.id2Service[v.id] = svc;
            }
        }
        return map;
    }
}

// https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md
// https://tools.ietf.org/html/draft-bhutton-json-schema-00#section-4.2.1
class ApiDocUtil {
    static init(proto) {
        // Custom types
        proto.types['?mongodb/ObjectId'] = proto.types['?mongodb/ObjectID'] =
            proto.types['?bson/ObjectId'] = proto.types['?bson/ObjectID'] = {
                type: tsbufferSchema.SchemaType.Custom,
                validate: v => ({ isSucc: true })
            };
        let generator = new tsbufferValidator.TSBufferValidator(proto.types);
        this.protoHelper = generator.protoHelper;
    }
    static toOpenAPI(proto) {
        // schemas
        let schemas = {};
        for (let key in proto.types) {
            schemas[key.replace(/[\.\/]/g, '_')] = this.toSchemaObject(proto.types[key]);
        }
        let apiSvcs = Object.values(ServiceMapUtil.getServiceMap(proto).apiName2Service);
        let pathObj = Object.fromEntries(apiSvcs.map(v => {
            var _a;
            let nameArr = v.name.split('/');
            let lastName = nameArr.last();
            let tags = nameArr.length > 1 ? [nameArr.slice(0, nameArr.length - 1).join('/')] : undefined;
            let pathValue = {
                post: {
                    tags: tags,
                    description: (_a = schemas[v.reqSchemaId]) === null || _a === void 0 ? void 0 : _a.description,
                    operationId: v.name,
                    requestBody: {
                        description: `Req<${lastName}>`,
                        content: {
                            'application/json': {
                                schema: {
                                    $ref: '#/components/schemas/' + v.reqSchemaId.replace(/[\.\/]/g, '_')
                                }
                            }
                        }
                    },
                    responses: {
                        200: {
                            description: 'Success',
                            content: {
                                'application/json': {
                                    schema: {
                                        type: 'object',
                                        description: `ApiReturn<Res${lastName}>`,
                                        properties: {
                                            isSucc: {
                                                type: 'boolean',
                                                enum: [true],
                                                default: true
                                            },
                                            res: {
                                                $ref: '#/components/schemas/' + v.resSchemaId.replace(/[\.\/]/g, '_')
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        default: {
                            description: 'Error',
                            $ref: '#/components/responses/error'
                        }
                    }
                }
            };
            return ['/' + v.name, pathValue];
        }));
        let output = {
            openapi: '3.0.0',
            info: {
                title: 'TSRPC Open API',
                version: '1.0.0'
            },
            paths: pathObj,
            components: {
                schemas: schemas,
                responses: {
                    error: {
                        description: 'Error',
                        content: {
                            'application/json': {
                                schema: {
                                    type: 'object',
                                    title: 'API 错误',
                                    description: '业务错误（ApiError）返回 HTTP 状态码 200，其它错误返回 HTTP 状态码 500',
                                    properties: {
                                        isSucc: {
                                            type: 'boolean',
                                            enum: [false],
                                            default: false
                                        },
                                        err: {
                                            type: 'object',
                                            description: 'TsrpcError',
                                            properties: {
                                                message: {
                                                    type: 'string'
                                                },
                                                type: {
                                                    type: 'string',
                                                    enum: ['ApiError', 'NetworkError', 'ServerError', 'ClientError']
                                                },
                                                code: {
                                                    oneOf: [
                                                        { type: 'string' },
                                                        { type: 'integer' }
                                                    ],
                                                    nullable: true
                                                }
                                            },
                                            required: ['message', 'type']
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        return output;
    }
    static toSchemaObject(schema) {
        var _a;
        let output = {};
        switch (schema.type) {
            case tsbufferSchema.SchemaType.Boolean:
                output.type = 'boolean';
                break;
            case tsbufferSchema.SchemaType.Number:
                if (schema.scalarType && schema.scalarType.indexOf('int') > -1) {
                    output.type = 'integer';
                }
                else {
                    output.type = 'number';
                }
                break;
            case tsbufferSchema.SchemaType.String:
                output.type = 'string';
                break;
            case tsbufferSchema.SchemaType.Array:
                output = {
                    ...output,
                    type: 'array',
                    items: this.toSchemaObject(schema.elementType)
                };
                break;
            case tsbufferSchema.SchemaType.Tuple:
                output = {
                    ...output,
                    type: 'array',
                    prefixItems: schema.elementTypes.map(v => this.toSchemaObject(v))
                };
                break;
            case tsbufferSchema.SchemaType.Enum:
                if (schema.members.every(v => typeof v.value === 'string')) {
                    output.type = 'string';
                }
                else if (schema.members.every(v => typeof v.value === 'number')) {
                    output.type = 'number';
                }
                else {
                    output.oneOf = [{ type: 'string' }, { type: 'number' }];
                }
                output.enum = schema.members.map(v => v.value);
                break;
            case tsbufferSchema.SchemaType.Any:
                output.type = 'object';
                break;
            case tsbufferSchema.SchemaType.Literal:
                if (schema.literal === null) {
                    output.nullable = true;
                    break;
                }
                let type = typeof schema.literal;
                if (type === 'bigint' || type === 'symbol' || type === 'function' || type === 'undefined') {
                    break;
                }
                output.type = type;
                output.enum = [schema.literal];
                break;
            case tsbufferSchema.SchemaType.Object:
                output.type = 'object';
                break;
            case tsbufferSchema.SchemaType.Interface: {
                output.type = 'object';
                // properties
                if (schema.properties) {
                    let schemaProperties = Object.merge([], schema.properties);
                    output.properties = Object.fromEntries(schemaProperties.map(property => {
                        // A | null | undefined -> A?
                        if (property.type.type === tsbufferSchema.SchemaType.Union) {
                            let members = property.type.members.filter(v => !(v.type.type === tsbufferSchema.SchemaType.Literal && v.type.literal == null));
                            if (members.length !== property.type.members.length) {
                                property.optional = true;
                                if (members.length === 1) {
                                    property.type = members[0].type;
                                }
                                else {
                                    property.type.members = members;
                                }
                            }
                        }
                        return [property.name, this.toSchemaObject(property.type)];
                    }));
                    output.required = schemaProperties.filter(v => !v.optional).map(v => v.name);
                    if (output.required.length === 0) {
                        output.required = undefined;
                    }
                }
                else {
                    output.properties = {};
                }
                // index signature
                if (schema.indexSignature) {
                    output.additionalProperties = this.toSchemaObject(schema.indexSignature.type);
                }
                // extends
                if (schema.extends) {
                    output = {
                        allOf: [
                            ...schema.extends.map(v => this.toSchemaObject(v.type)),
                            output
                        ]
                    };
                }
                break;
            }
            case tsbufferSchema.SchemaType.Buffer:
                output.type = 'string';
                output.format = 'base64';
                break;
            case tsbufferSchema.SchemaType.IndexedAccess: {
                let parsed = this.protoHelper.parseReference(schema);
                output = {
                    ...output,
                    ...this.toSchemaObject(parsed)
                };
                break;
            }
            case tsbufferSchema.SchemaType.Reference:
                output.$ref = '#/components/schemas/' + schema.target.replace(/[\.\/]/g, '_');
                break;
            case tsbufferSchema.SchemaType.Union: {
                let members = schema.members.filter(v => {
                    let type = v.type;
                    return !(type.type === tsbufferSchema.SchemaType.Literal && type.literal == null);
                });
                // null | undefined
                if (members.length === 0) {
                    output.nullable = true;
                    break;
                }
                // A | null | undefined
                else if (members.length === 1) {
                    output = this.toSchemaObject(members[0].type);
                }
                // >= 2 members
                else {
                    // Check if discriminator
                    // Every member is interface
                    let flats = members.map(v => this.protoHelper.isInterface(v.type) ? this.protoHelper.getFlatInterfaceSchema(v.type) : null);
                    if (flats.every(v => !!v)) {
                        // Every member has a same literal property
                        (_a = flats[0]) === null || _a === void 0 ? void 0 : _a.properties.some(disProp => {
                            let literalTypes = flats.map(f => {
                                let prop = f === null || f === void 0 ? void 0 : f.properties.find(v => v.name === disProp.name);
                                if (!prop || prop.type.type !== tsbufferSchema.SchemaType.Literal || prop.optional) {
                                    return null;
                                }
                                return prop.type;
                            });
                            // Every literal value is different
                            if (literalTypes.every(v => !!v)) {
                                let uniqueLiterals = literalTypes.map(v => v.literal).distinct();
                                if (uniqueLiterals.length === literalTypes.length) {
                                    // Yes! This is the discriminator key
                                    output.oneOf = members.map(v => this.toSchemaObject(v.type));
                                    output.discriminator = {
                                        propertyName: disProp.name,
                                        // mapping: Object.fromEntries(flats.map((v, i) => {
                                        //     let lProp = v!.properties.find(v1 => v1.name === disProp.name)!;
                                        //     let lType = lProp.type as LiteralTypeSchema;
                                        //     return [lType.literal, this.toSchemaObject(members[i].type)]
                                        // }))
                                    };
                                }
                            }
                        });
                    }
                    // Not discriminator: anyOf
                    if (!output.discriminator) {
                        let anyOf = members.map(v => JSON.stringify(this.toSchemaObject(v.type))).distinct().map(v => JSON.parse(v));
                        if (anyOf.length > 1) {
                            output.anyOf = anyOf;
                        }
                        else {
                            output = anyOf[0];
                        }
                    }
                }
                // X | null
                if (members.length !== schema.members.length) {
                    output.nullable = true;
                }
                break;
            }
            case tsbufferSchema.SchemaType.Intersection:
                output.allOf = schema.members.map(v => this.toSchemaObject(v.type));
                break;
            case tsbufferSchema.SchemaType.NonNullable:
                output = this.toSchemaObject(schema.target);
                output.nullable = false;
                break;
            case tsbufferSchema.SchemaType.Date:
                output.type = 'string';
                output.format = 'date-time';
                break;
            case tsbufferSchema.SchemaType.Pick:
            case tsbufferSchema.SchemaType.Partial:
            case tsbufferSchema.SchemaType.Omit:
            case tsbufferSchema.SchemaType.Overwrite: {
                let parsed = this._parseMappedType(schema);
                output = this.toSchemaObject(parsed);
                break;
            }
            case tsbufferSchema.SchemaType.Custom:
                output.type = 'string';
                break;
        }
        output.description = schema.comment;
        return output;
    }
    static async toCode(proto, schemaId, typeName) {
        let schema = proto[schemaId];
        // Get circular refs
        this._genCircularData = {
            refStack: [],
            proto: proto,
            output: []
        };
        this._generateCircularRefs(schema);
        // Circular refs would be kept
        this._toCodeData = {
            refs: this._genCircularData.output
        };
        let code = this._toCode(schema, { isRoot: true });
        code = `${this.protoHelper.isInterface(schema) ? `interface ${typeName}` : `type ${typeName} =`} ${code}`;
        // Generate code of refs
        if (this._toCodeData.refs.length) {
            code += '\n\n' + this._toCodeData.refs.map(v => {
                let refName = v.split('/').last();
                let refCode = this._toCode(proto[v], { isRoot: true });
                refCode = `${this.protoHelper.isInterface(schema) ? `interface ${refName}` : `type ${refName} =`} ${refCode}`;
                if (proto[v].comment) {
                    refCode = this._toCodeComment(proto[v].comment) + '\n' + refCode;
                }
                return refCode;
            }).join('\n\n');
        }
        // Clear
        this._genCircularData = undefined;
        this._toCodeData = undefined;
        // Format
        let format = await typescriptFormatter.processString('a.ts', code, {});
        return format.dest;
    }
    static _generateCircularRefs(schema) {
        var _a, _b, _c, _d;
        switch (schema.type) {
            case tsbufferSchema.SchemaType.Array:
                this._generateCircularRefs(schema.elementType);
                return;
            case tsbufferSchema.SchemaType.Tuple:
                schema.elementTypes.forEach(v => { this._generateCircularRefs(v); });
                return;
            case tsbufferSchema.SchemaType.Interface:
                (_a = schema.extends) === null || _a === void 0 ? void 0 : _a.forEach(v => { this._generateCircularRefs(v.type); });
                (_b = schema.properties) === null || _b === void 0 ? void 0 : _b.forEach(v => { this._generateCircularRefs(v.type); });
                schema.indexSignature && this._generateCircularRefs(schema.indexSignature.type);
                return;
            case tsbufferSchema.SchemaType.IndexedAccess:
                this._generateCircularRefs(schema.objectType);
                return;
            case tsbufferSchema.SchemaType.Reference:
                if (this._genCircularData.output.includes(schema.target)) {
                    return;
                }
                if (this._genCircularData.refStack.includes(schema.target)) {
                    this._genCircularData.output.push(schema.target);
                    return;
                }
                (_c = this._genCircularData) === null || _c === void 0 ? void 0 : _c.refStack.push(schema.target);
                this._generateCircularRefs(this._genCircularData.proto[schema.target]);
                (_d = this._genCircularData) === null || _d === void 0 ? void 0 : _d.refStack.pop();
                return;
            case tsbufferSchema.SchemaType.Union:
            case tsbufferSchema.SchemaType.Intersection:
                schema.members.forEach(v => { this._generateCircularRefs(v.type); });
                return;
            case tsbufferSchema.SchemaType.NonNullable:
                this._generateCircularRefs(schema.target);
                return;
            case tsbufferSchema.SchemaType.Pick:
            case tsbufferSchema.SchemaType.Partial:
            case tsbufferSchema.SchemaType.Omit:
                this._generateCircularRefs(schema.target);
                return;
            case tsbufferSchema.SchemaType.Overwrite:
                this._generateCircularRefs(schema.target);
                this._generateCircularRefs(schema.overwrite);
                return;
        }
    }
    static _toCode(schema, options) {
        var _a;
        switch (schema.type) {
            case tsbufferSchema.SchemaType.Boolean:
                return 'boolean';
            case tsbufferSchema.SchemaType.Number:
                if (schema.scalarType && schema.scalarType !== 'double') {
                    return `/*${schema.scalarType}*/ number`;
                }
                return 'number';
            case tsbufferSchema.SchemaType.String:
                return 'string';
            case tsbufferSchema.SchemaType.Array:
                let elemType = this.protoHelper.isTypeReference(schema.elementType) ? this.protoHelper.parseReference(schema.elementType) : schema.elementType;
                let code = this._toCode(schema.elementType);
                return (elemType.type === tsbufferSchema.SchemaType.Union || elemType.type === tsbufferSchema.SchemaType.Intersection) ? `(${code})[]` : `${code}[]`;
            case tsbufferSchema.SchemaType.Tuple:
                return `[${schema.elementTypes.map((v, i) => this._toCode(v)
                    + (schema.optionalStartIndex !== undefined && i >= schema.optionalStartIndex ? '?' : ''))
                    .join(', ')}]`;
            case tsbufferSchema.SchemaType.Enum:
                return schema.members.map(v => this._toCode({ type: tsbufferSchema.SchemaType.Literal, literal: v.value })).join(' | ');
            case tsbufferSchema.SchemaType.Any:
                return 'any';
            case tsbufferSchema.SchemaType.Literal:
                if (schema.literal === undefined) {
                    return 'undefined';
                }
                return JSON.stringify(schema.literal);
            case tsbufferSchema.SchemaType.Object:
                return 'object';
            case tsbufferSchema.SchemaType.Pick:
            case tsbufferSchema.SchemaType.Partial:
            case tsbufferSchema.SchemaType.Omit:
            case tsbufferSchema.SchemaType.Overwrite: {
                let parsed = this._parseMappedType(schema);
                return this._toCode(parsed);
            }
            case tsbufferSchema.SchemaType.Interface: {
                let flat = this.protoHelper.getFlatInterfaceSchema(schema);
                let props = [];
                for (let prop of flat.properties) {
                    let propStr = '';
                    // Comment
                    if (prop.type.comment) {
                        propStr += `${this._toCodeComment(prop.type.comment)}\n`;
                    }
                    // 字段无 Comment，但是是引用
                    else if (this.protoHelper.isTypeReference(prop.type)) {
                        // 引用有 Comment
                        let parsedSchema = this.protoHelper.parseReference(prop.type);
                        if (parsedSchema.comment) {
                            propStr += `${this._toCodeComment(parsedSchema.comment)}\n`;
                        }
                    }
                    propStr += (`${/^[a-z_]/i.test(prop.name) ? prop.name : `'${prop.name}'`}${prop.optional ? '?' : ''}: ${this._toCode(prop.type)}`);
                    props.push(propStr);
                }
                if (flat.indexSignature) {
                    props.push(`[key: ${flat.indexSignature.keyType.toLowerCase()}]: ${this._toCode(flat.indexSignature.type)}`);
                }
                return (props.length > 1 || (options === null || options === void 0 ? void 0 : options.isRoot)) ? `{\n${props.join(',\n')}\n}` : `{${props.join(', ')}}`;
            }
            case tsbufferSchema.SchemaType.Buffer:
                return '/*base64*/ string';
            case tsbufferSchema.SchemaType.IndexedAccess:
                return this._toCode(this.protoHelper.parseReference(schema));
            case tsbufferSchema.SchemaType.Reference: {
                if (this._toCodeData.refs.includes(schema.target)) {
                    return schema.target.split('/').last();
                }
                return this._toCode(this.protoHelper.parseReference(schema), { schemaId: schema.target });
            }
            case tsbufferSchema.SchemaType.Union:
                return schema.members.map(v => {
                    let parsed = this.protoHelper.isTypeReference(v.type) ? this.protoHelper.parseReference(v.type) : v.type;
                    let code = this._toCode(v.type);
                    return parsed.type === tsbufferSchema.SchemaType.Intersection ? `(${code})` : code;
                }).distinct().join(' | ');
            case tsbufferSchema.SchemaType.Intersection:
                return schema.members.map(v => {
                    let parsed = this.protoHelper.isTypeReference(v.type) ? this.protoHelper.parseReference(v.type) : v.type;
                    let code = this._toCode(v.type);
                    return parsed.type === tsbufferSchema.SchemaType.Union ? `(${code})` : code;
                }).distinct().join(' & ');
            case tsbufferSchema.SchemaType.NonNullable:
                return `NonNullable<${this._toCode(schema.target)}>`;
            case tsbufferSchema.SchemaType.Date:
                return '/*datetime*/ string';
            case tsbufferSchema.SchemaType.Custom: {
                let schemaId = (_a = options === null || options === void 0 ? void 0 : options.schemaId) === null || _a === void 0 ? void 0 : _a.toLowerCase();
                if (schemaId === '?mongodb/objectid' || schemaId === '?json/objectid') {
                    return '/*ObjectId*/ string';
                }
                return 'string';
            }
        }
        return '';
    }
    // #endregion _toCode
    static _parseMappedType(schema) {
        if (this.protoHelper.isInterface(schema)) {
            return this.protoHelper.getFlatInterfaceSchema(schema);
        }
        else {
            return this.protoHelper.parseMappedType(schema);
        }
    }
    static async toTSAPI(proto) {
        var _a, _b;
        let output = {
            version: '1.0.0',
            servers: ['http://localhost:3000'],
            apis: [],
            // schemas: {}
        };
        // Schema
        // for (let key in proto.types) {
        //     let basename = key.split('/').last()!;
        //     output.schemas[key] = {
        //         ts: await this.toCode(proto.types, key, basename)
        //     }
        // }
        // API
        let apiSvcs = Object.values(ServiceMapUtil.getServiceMap(proto).apiName2Service);
        for (let api of apiSvcs) {
            let basename = api.name.split('/').last();
            let commentArr = (_b = (_a = proto.types[api.reqSchemaId].comment) === null || _a === void 0 ? void 0 : _a.trim()) === null || _b === void 0 ? void 0 : _b.split('\n');
            let title = commentArr === null || commentArr === void 0 ? void 0 : commentArr[0].trim();
            let remark = commentArr === null || commentArr === void 0 ? void 0 : commentArr.slice(1).join('\n');
            output.apis.push({
                path: '/' + api.name,
                title: title,
                remark: remark,
                req: {
                    ts: await this.toCode(proto.types, api.reqSchemaId, `Req${basename}`),
                },
                res: {
                    ts: await this.toCode(proto.types, api.resSchemaId, `Res${basename}`),
                },
                conf: api.conf
            });
        }
        return output;
    }
    static toMarkdown(api) {
        let md = `
# TSRPC API 接口文档

## 通用说明

- 所有请求方法均为 \`POST\`
- 所有请求均需加入以下 Header :
    - \`Content-Type: application/json\`

`;
        md += '## 目录\n\n';
        md += this._treeToToc(this._toApiTree(api.apis, '/', 10), 1) + '\n---\n\n';
        md += this._treeToMarkdown(this._toApiTree(api.apis, '/', 3), 1);
        return md;
    }
    static _treeToToc(tree, currentDepth) {
        let output = '';
        // 逐个生成
        for (let node of tree) {
            // 写个标题
            if (node.type === 'api') {
                output += `${' '.repeat((currentDepth - 1) * 4)}- [${node.name}](#${node.api.path})\n`;
            }
            else if (node.type === 'folder') {
                output += `${' '.repeat((currentDepth - 1) * 4)}- ${node.name}\n`;
                output += this._treeToToc(node.children, currentDepth + 1);
            }
        }
        return output;
    }
    static _treeToMarkdown(tree, currentDepth) {
        let output = [];
        // 逐个生成
        for (let node of tree) {
            // 写个标题
            let part = `${'#'.repeat(currentDepth + 1)} ${node.name}${node.type === 'api' ? ` <a id="${node.api.path}"></a>` : ''}\n\n`;
            // folder
            if (node.type === 'folder') {
                // 递归
                part += this._treeToMarkdown(node.children, currentDepth + 1);
            }
            // api
            else if (node.type === 'api') {
                // 请求响应……正文内容
                if (node.api.remark) {
                    part += node.api.remark + '\n\n';
                }
                part += `**路径**\n- POST \`${node.api.path}\`\n\n`;
                part += '**请求**\n```ts\n' + node.api.req.ts + '\n```\n\n';
                part += '**响应**\n```ts\n' + node.api.res.ts + '\n```\n\n';
                if (node.api.conf && (typeof node.api.conf !== 'object' || Object.keys(node.api.conf).length > 0)) {
                    part += '**配置**\n```ts\n' + JSON.stringify(node.api.conf, null, 2) + '\n```\n\n';
                }
            }
            output.push(part);
        }
        return output.join('---\n\n');
    }
    static _toApiTree(apis, prefix, maxDepth) {
        // 按前缀过滤（保护）
        apis = apis.filter(v => v.path.startsWith(prefix));
        let typedApis = apis.map(v => {
            let arrPrefix = prefix.split('/');
            let isLastFolderDepth = arrPrefix.length === maxDepth;
            let groupArr = v.path.slice(prefix.length).split('/');
            let groupName = isLastFolderDepth ? groupArr.slice(0, -1).join('/') : groupArr[0];
            return {
                type: groupArr.length > 1 ? 'folder' : 'api',
                groupName: groupName,
                api: v
            };
        });
        // 计算这一级的 API 节点
        let apiNodes = typedApis.filter(v => v.type === 'api').map(v => {
            return {
                type: 'api',
                name: v.api.title || v.api.path.split('/').last(),
                api: v.api
            };
        });
        // 整理这一级的 folder 节点
        let folderNodes = typedApis.filter(v => v.type === 'folder').groupBy(v => v.groupName)
            .map(v => ({
            type: 'folder',
            name: v.key,
            children: this._toApiTree(v.map(v1 => v1.api), prefix + v.key + '/', maxDepth)
        }));
        // 排序
        return [
            ...folderNodes.orderBy(v => v.name),
            ...apiNodes.orderBy(v => v.api.path)
        ];
    }
    /** 将 TSBufferProto 的 comment 还原为代码注释 */
    static _toCodeComment(comment) {
        let arr = comment.split('\n');
        if (arr.length === 1) {
            return `/** ${comment} */`;
        }
        else {
            return `/**
${arr.map(v => `* ${v}`).join('\n')}
*/`;
        }
    }
}
ApiDocUtil._refStack = [];

async function cmdDoc(options) {
    if (options.config) {
        if (!options.config.proto) {
            throw new Error(i18n.missingConfigItem('proto'));
        }
        for (let conf of options.config.proto) {
            options.config.verbose && console.log(`Start to generate ${conf.output}...`);
            if (!conf.docDir) {
                continue;
            }
            await generate(conf.ptlDir, conf.docDir, conf.ignore, options.config.verbose);
            console.log(chalk__default["default"].bgGreen.white(i18n.success));
        }
    }
    else {
        // 检查参数
        if (typeof options.input !== 'string') {
            throw error(i18n.missingParam, { param: 'input' });
        }
        if (typeof options.output !== 'string') {
            throw error(i18n.missingParam, { param: 'output' });
        }
        await generate(options.input, options.output, options.ignore, options.verbose);
        console.log(chalk__default["default"].bgGreen.white(i18n.success));
    }
}
async function generate(ptlDir, outDir, ignore, verbose) {
    // Generate proto
    let { newProto } = await ProtoUtil.generateServiceProto({
        protocolDir: ptlDir,
        ignore: ignore,
        verbose: verbose,
        checkOptimize: false,
        keepComment: true
    });
    ApiDocUtil.init(newProto);
    await generateOpenApi(newProto, outDir);
    let tsrpcAPI = await generateTSAPI(newProto);
    await generateMarkdown(tsrpcAPI, outDir);
}
async function generateOpenApi(proto, outputDir) {
    // Generate OpenAPI
    let openAPI = ApiDocUtil.toOpenAPI(proto);
    // Output OpenAPI
    await fs__default$1["default"].ensureDir(outputDir);
    let outputPath = path__default["default"].resolve(outputDir, 'openapi.json');
    await fs__default$1["default"].writeFile(outputPath, JSON.stringify(openAPI, null, 2), 'utf-8');
    console.log(chalk__default["default"].green(i18n.docOpenApiSucc(outputPath)));
}
async function generateTSAPI(proto, outputDir) {
    // Generate OpenAPI
    let tsrpcAPI = await ApiDocUtil.toTSAPI(proto);
    // Output OpenAPI
    // await fs.ensureDir(outputDir);
    // let outputPath = path.resolve(outputDir, 'tsapi.json');
    // await fs.writeFile(outputPath, JSON.stringify(tsrpcAPI, null, 2), 'utf-8');
    // console.log(chalk.green(i18n.docTsapiSucc(outputPath)))
    return tsrpcAPI;
}
async function generateMarkdown(api, outputDir) {
    let md = ApiDocUtil.toMarkdown(api);
    await fs__default$1["default"].ensureDir(outputDir);
    let outputPath = path__default["default"].resolve(outputDir, 'tsapi.md');
    await fs__default$1["default"].writeFile(outputPath, md, 'utf-8');
    console.log(chalk__default["default"].green(i18n.docMdSucc(outputPath)));
}

async function cmdEncode(options) {
    let parsedProto = await ProtoUtil.parseProtoAndSchema(options.proto, options.schemaId);
    // #region 解析Input Value
    let inputValue;
    if (options.input) {
        let fileContent;
        try {
            fileContent = fs__default["default"].readFileSync(options.input).toString();
        }
        catch {
            throw console$1.error(i18n.fileOpenError, { file: path__default["default"].resolve(options.input) });
        }
        try {
            inputValue = eval(fileContent);
        }
        catch {
            throw console$1.error(i18n.jsParsedError, { file: path__default["default"].resolve(options.input) });
        }
    }
    else if (options.exp) {
        try {
            inputValue = eval(`()=>(${options.exp})`)();
        }
        catch (e) {
            if (options.verbose) {
                console.log('exp', options.exp);
                console.error(e);
            }
            throw console$1.error(i18n.expParsedError);
        }
    }
    else {
        throw console$1.error(i18n.missingParam, { param: `--input ${i18n.or} [expression]` });
    }
    // #endregion
    options.verbose && console.log('inputValue', inputValue);
    let opEncode = new tsbuffer.TSBuffer(parsedProto.proto).encode(inputValue, parsedProto.schemaId);
    if (!opEncode.isSucc) {
        throw console$1.error('编码失败。\n    ' + opEncode.errMsg);
    }
    console.log('编码长度：' + opEncode.buf.byteLength);
    if (options.output) {
        fs__default["default"].writeFileSync(options.output, opEncode.buf);
        console.log(chalk__default["default"].green(formatStr(i18n.encodeSucc, { output: path__default["default"].resolve(options.output) })));
    }
    else {
        console.log(chalk__default["default"].yellow(buf2Hex(opEncode.buf)));
    }
}

async function cmdInit(options) {
    if (await fs__default$1["default"].pathExists('tsrpc.config.ts')) {
        throw new Error(i18n.fileAlreadyExists('tsrpc.config.ts'));
    }
    if (!await fs__default$1["default"].pathExists('package.json')) {
        throw new Error(i18n.npmNotInited);
    }
    await fs__default$1["default"].copyFile(path__default["default"].join(resPath, 'tsrpc.config.ts'), 'tsrpc.config.ts');
    let packageJson = JSON.parse(await fs__default$1["default"].readFile('package.json', 'utf-8'));
    Object.merge(packageJson, {
        "scripts": {
            "dev": "tsrpc-cli dev",
            "build": "tsrpc-cli build",
            "doc": "tsrpc-cli doc",
        }
    });
    await fs__default$1["default"].writeFile('package.json', JSON.stringify(packageJson, null, 2), 'utf-8');
    console.log(chalk__default["default"].green(i18n.initSucc(path__default["default"].resolve('tsrpc.config.ts'))));
}

async function cmdProto(options) {
    if (options.config) {
        if (!options.config.proto) {
            throw new Error(i18n.missingConfigItem('proto'));
        }
        for (let conf of options.config.proto) {
            options.config.verbose && console.log(`Start to generate ${conf.output}...`);
            // 填充空白协议文件
            await fillAllPtlAndMsgs(conf);
            // old
            let old = await ProtoUtil.loadOldProtoByConfigItem(conf, options.config.verbose);
            // new
            await ProtoUtil.genProtoByConfigItem(conf, old, options.config.verbose, options.config.checkOptimizableProto);
        }
    }
    else {
        // 检查参数
        if (!options.input) {
            throw error(i18n.missingParam, { param: 'input' });
        }
        if (!options.output) {
            throw error(i18n.missingParam, { param: 'output' });
        }
        // oldProto
        let old = await ProtoUtil.loadOldProtoByConfigItem({
            compatible: options.compatible,
            output: options.output
        }, options.verbose);
        // newProto
        await ProtoUtil.genProtoByConfigItem({
            ptlDir: options.input,
            ignore: options.ignore,
            output: options.output
        }, old, options.verbose, true);
    }
}

function cmdShowBin(options) {
    let buf;
    try {
        buf = new Uint8Array(fs__default["default"].readFileSync(options.file));
        console.log('编码长度：' + buf.byteLength);
    }
    catch (e) {
        options.verbose && console.error(e);
        throw console$1.error(i18n.fileOpenError, { file: path__default["default"].resolve(options.file) });
    }
    console.log(chalk__default["default"].yellow(buf2Hex(buf)));
}

function cmdShowHelp() {
    showLogo();
    console.log(chalk__default["default"].green(formatStr(i18n.welcome, { version: '2.4.3' })));
    console.log('\n' + i18n.help);
    console.log('\n' + i18n.example);
}

async function cmdValidate(options) {
    let parsedProto = await ProtoUtil.parseProtoAndSchema(options.proto, options.schemaId);
    // #region 解析Input Value
    let inputValue;
    if (options.input) {
        let fileContent;
        try {
            fileContent = fs__default["default"].readFileSync(options.input).toString();
        }
        catch {
            throw error(i18n.fileOpenError, { file: path__default["default"].resolve(options.input) });
        }
        try {
            inputValue = eval(fileContent);
        }
        catch {
            throw error(i18n.jsParsedError, { file: path__default["default"].resolve(options.input) });
        }
    }
    else if (options.expression) {
        try {
            inputValue = eval(`()=>(${options.expression})`)();
        }
        catch (e) {
            if (options.verbose) {
                console.log('exp', options.expression);
                console.error(e);
            }
            throw error(i18n.expParsedError);
        }
    }
    else {
        throw error(i18n.missingParam, { param: `--input ${i18n.or} [expression]` });
    }
    // #endregion
    let vRes = new tsbuffer.TSBuffer(parsedProto.proto).validate(inputValue, parsedProto.schemaId);
    if (vRes.isSucc) {
        console.log(chalk__default["default"].green(i18n.validateSucc));
    }
    else {
        throw error(i18n.validateFail, { msg: vRes.errMsg });
    }
}

const args = minimist__default["default"](process.argv.slice(2));
const resPath = path__default["default"].resolve(__dirname, './res/') ;
// 延迟 1 Tick 进入主流程（防止 tsrpc.config.ts 循环引用）
main().catch((e) => {
    var _a;
    CliUtil.done(false);
    if (args.verbose) {
        console.error('\n' + chalk__default["default"].bgRed.white(i18n.error), e);
    }
    else {
        console.error('\n' + chalk__default["default"].bgRed.white(i18n.error), chalk__default["default"].red((_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : e));
    }
    process.exit(-1);
});
async function main() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    let conf;
    if (Object.keys(args).filter(v => v !== '_').length === 0 && args._[0] !== 'init' || args._[0] === 'dev' && !args.config) {
        args.config = 'tsrpc.config.ts';
    }
    if (args.config) {
        conf = importTsrpcConfig(args.config);
    }
    if (conf === null || conf === void 0 ? void 0 : conf.cwd) {
        process.chdir(conf.cwd);
    }
    // depreated config 兼容
    if (conf) {
        (_a = conf.proto) === null || _a === void 0 ? void 0 : _a.forEach(v => {
            var _a, _b, _c;
            v.ptlTemplate = (_a = v.ptlTemplate) !== null && _a !== void 0 ? _a : v.newPtlTemplate;
            v.msgTemplate = (_b = v.msgTemplate) !== null && _b !== void 0 ? _b : v.newMsgTemplate;
            v.apiTemplate = (_c = v.apiTemplate) !== null && _c !== void 0 ? _c : v.newApiTemplate;
        });
    }
    // Version
    if (args._.length === 0 && (args.version || args.v)) {
        console.log('2.4.3');
    }
    // Help
    else if (args.h || args.help) {
        cmdShowHelp();
    }
    // Proto
    else if (args._[0] === 'proto') {
        await cmdProto({
            input: (_b = args.input) !== null && _b !== void 0 ? _b : args.i,
            output: (_c = args.output) !== null && _c !== void 0 ? _c : args.o,
            compatible: (_d = args.compatible) !== null && _d !== void 0 ? _d : args.c,
            ugly: args.ugly,
            new: args.new,
            ignore: args.ignore,
            verbose: args.verbose,
            config: conf
        });
    }
    // Api
    else if (args._[0] === 'api') {
        await cmdApi({
            input: (_e = args.input) !== null && _e !== void 0 ? _e : args.i,
            output: (_f = args.output) !== null && _f !== void 0 ? _f : args.o,
            config: conf
        });
    }
    // Encode
    else if (args._[0] === 'encode') {
        cmdEncode({
            exp: args._[1],
            input: (_g = args.input) !== null && _g !== void 0 ? _g : args.i,
            output: (_h = args.output) !== null && _h !== void 0 ? _h : args.o,
            proto: (_j = args.proto) !== null && _j !== void 0 ? _j : args.p,
            schemaId: (_k = args.schema) !== null && _k !== void 0 ? _k : args.s,
            verbose: args.verbose
        });
    }
    // Decode
    else if (args._[0] === 'decode') {
        cmdDecode({
            protoPath: (_l = args.proto) !== null && _l !== void 0 ? _l : args.p,
            schemaId: (_m = args.schema) !== null && _m !== void 0 ? _m : args.s,
            binStr: args._[1],
            input: (_o = args.input) !== null && _o !== void 0 ? _o : args.i,
            output: (_p = args.output) !== null && _p !== void 0 ? _p : args.o,
            verbose: args.verbose
        });
    }
    // Validate
    else if (args._[0] === 'validate') {
        cmdValidate({
            proto: (_q = args.proto) !== null && _q !== void 0 ? _q : args.p,
            schemaId: (_r = args.schema) !== null && _r !== void 0 ? _r : args.s,
            input: (_s = args.input) !== null && _s !== void 0 ? _s : args.i,
            expression: args._[1],
            verbose: args.verbose
        });
    }
    // Show
    else if (args._[0] === 'show') {
        if (!args._[1]) {
            throw error(i18n.missingParam, { param: '<file>' });
        }
        cmdShowBin({
            file: args._[1],
            verbose: args.verbose
        });
    }
    // Sync
    else if (args._[0] === 'sync') {
        await cmdSync({
            from: args.from,
            to: args.to,
            verbose: args.verbose,
            config: conf
        });
    }
    // Dev
    else if (args._[0] === 'dev') {
        if (!conf) {
            throw error(i18n.missingParam, { param: 'config' });
        }
        if (!conf.dev) {
            throw new Error(i18n.missingConfigItem('dev'));
        }
        await cmdDev({
            config: conf,
            entry: args.entry
        });
        return;
    }
    // Build
    else if (args._[0] === 'build') {
        await cmdBuild({
            config: conf
        });
    }
    // Link
    else if (args._[0] === 'link') {
        await cmdLink({
            elevate: args.elevate,
            from: args.from,
            to: args.to,
            verbose: args.verbose,
            config: conf
        });
    }
    // Doc
    else if (args._[0] === 'doc' || args._[0] === 'docs') {
        await cmdDoc({
            input: (_t = args.input) !== null && _t !== void 0 ? _t : args.i,
            output: (_u = args.output) !== null && _u !== void 0 ? _u : args.o,
            ignore: args.ignore,
            verbose: args.verbose,
            config: conf
        });
    }
    // Init
    else if (args._[0] === 'init') {
        await cmdInit();
    }
    // Error
    // No Command
    else if (args._.length === 0) {
        showLogo();
        console.log(chalk__default["default"].green(formatStr(i18n.welcome, { version: '2.4.3' })));
        console.log('\n' + i18n.example);
        console.log('\n' + chalk__default["default"].yellow(i18n.helpGuide));
    }
    else {
        throw error(i18n.errCmd);
    }
    CliUtil.done(true);
    process.exit(0);
}
// process.on('uncaughtException', e => {
//     console.error('uncaughtException', e)
// })
// process.on('unhandledRejection', e => {
//     console.error('unhandledRejection', e)
// })

exports.resPath = resPath;
